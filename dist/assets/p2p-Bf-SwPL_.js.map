{"version":3,"file":"p2p-Bf-SwPL_.js","sources":["../../src/setup/gameSetup.ts","../../src/p2p/protocol.ts","../../src/p2p/stateSync.ts","../../src/p2p/browserRoom.ts","../../src/p2p/browserClient.ts"],"sourcesContent":["/**\r\n * GAME SETUP - Initial state creation\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * This is the ONLY place where randomness occurs in the entire game.\r\n * After setup completes, the game is fully deterministic.\r\n * \r\n * Key Properties:\r\n * 1. DETERMINISTIC: Same seed + players = identical game state\r\n * 2. REPRODUCIBLE: Can recreate exact game for testing/replay\r\n * 3. ATOMIC: Setup creates complete initial state in one call\r\n * 4. SERIALIZABLE: Resulting state is fully JSON-safe\r\n * 5. SEED-BASED: Randomness controlled by seed parameter\r\n * \r\n * Why Seeded Randomness:\r\n * - Enables game replay/debugging (use same seed)\r\n * - Allows fair tournaments (everyone gets same card distribution)\r\n * - Server can verify game setup integrity\r\n * - Clients can't manipulate randomness\r\n * - Tests are reproducible and reliable\r\n * \r\n * Async Usage Pattern:\r\n * ```typescript\r\n * // Server creates new game:\r\n * const seed = generateSecureSeed(); // e.g., UUID or timestamp\r\n * const players = [{id: 'p1', name: 'Alice'}, {id: 'p2', name: 'Bob'}];\r\n * const initialState = createNewGame(players, seed);\r\n * \r\n * // Save to database:\r\n * await saveGameState(initialState);\r\n * \r\n * // Broadcast to all players:\r\n * await notifyPlayers(initialState.players, initialState);\r\n * ```\r\n * \r\n * After Setup:\r\n * - All randomness is exhausted (cards shuffled, coins placed)\r\n * - Game proceeds deterministically based on player actions\r\n * - No more random events (dice, draws from shuffled deck are deterministic)\r\n * - State can be saved/loaded/replayed without randomness concerns\r\n */\r\n\r\nimport {\r\n  Game,\r\n  Player,\r\n  MerchantCard,\r\n  PointCard,\r\n  CrystalColor,\r\n  GamePhase,\r\n  MerchantCardType,\r\n  CrystalSet,\r\n  GameConfig\r\n} from '../types/domain';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport type PlayerInput = {\r\n  id: string;\r\n  name: string;\r\n};\r\n\r\n// ============================================================================\r\n// GAME CONSTANTS\r\n// ============================================================================\r\n\r\n// Standard game configuration for 2-5 players\r\nconst DEFAULT_CONFIG: GameConfig = {\r\n  playerCount: 2,\r\n  caravanCapacity: 10,\r\n  merchantRowSize: 6,\r\n  pointCardRowSize: 5,\r\n  pointCardsToTriggerEnd: 5 // 4 in 2-3 player, 5 in 4+ player\r\n};\r\n\r\n// Coin values placed on point cards during setup\r\nconst COPPER_COIN_VALUE = 1;\r\nconst SILVER_COIN_VALUE = 3;\r\n\r\n// ============================================================================\r\n// DETERMINISTIC SHUFFLE\r\n// ============================================================================\r\n\r\n/**\r\n * Simple LCG-based PRNG for deterministic shuffling.\r\n * Uses seed string to generate reproducible random sequence.\r\n */\r\nfunction createSeededRandom(seed: string): () => number {\r\n  let state = 0;\r\n  for (let i = 0; i < seed.length; i++) {\r\n    state = ((state << 5) - state + seed.charCodeAt(i)) | 0;\r\n  }\r\n  state = Math.abs(state);\r\n\r\n  return function() {\r\n    state = (state * 1664525 + 1013904223) | 0;\r\n    return Math.abs(state) / 2147483648;\r\n  };\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle using seeded random generator.\r\n */\r\nfunction shuffleArray<T>(array: T[], random: () => number): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}\r\n\r\n// ============================================================================\r\n// CARD CREATION\r\n// ============================================================================\r\n\r\n/**\r\n * Creates the full merchant deck according to the rulebook.\r\n * \r\n * Assumptions based on Century: Golem Edition rulebook:\r\n * - Produce cards: Various combinations producing 1-4 yellow/green crystals\r\n * - Upgrade cards: Single and double upgrades, various configurations\r\n * - Trade cards: Various exchange patterns\r\n */\r\nfunction createMerchantDeck(): MerchantCard[] {\r\n  const cards: MerchantCard[] = [];\r\n  let idCounter = 1;\r\n\r\n  const emptyCrystals = (): CrystalSet => ({\r\n    [CrystalColor.Yellow]: 0,\r\n    [CrystalColor.Green]: 0,\r\n    [CrystalColor.Red]: 0,\r\n    [CrystalColor.Blue]: 0\r\n  });\r\n\r\n  // PRODUCE CARDS (8 cards)\r\n  // 2 yellow\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 }\r\n  });\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 }\r\n  });\r\n  \r\n  // 3 yellow\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 3 }\r\n  });\r\n  \r\n  // 4 yellow\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 4 }\r\n  });\r\n  \r\n  // 1 green\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Green]: 1 }\r\n  });\r\n  \r\n  // 2 green\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Green]: 2 }\r\n  });\r\n  \r\n  // 1 yellow, 1 green\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 1, [CrystalColor.Green]: 1 }\r\n  });\r\n  \r\n  // 2 yellow, 1 green\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Produce,\r\n    produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Green]: 1 }\r\n  });\r\n\r\n  // UPGRADE CARDS (14 cards)\r\n  // Upgrade 2 once\r\n  for (let i = 0; i < 5; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Upgrade,\r\n      upgrades: [{ count: 2, times: 1 }]\r\n    });\r\n  }\r\n  \r\n  // Upgrade 3 once\r\n  for (let i = 0; i < 4; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Upgrade,\r\n      upgrades: [{ count: 3, times: 1 }]\r\n    });\r\n  }\r\n  \r\n  // Upgrade 1 twice\r\n  for (let i = 0; i < 3; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Upgrade,\r\n      upgrades: [{ count: 1, times: 2 }]\r\n    });\r\n  }\r\n  \r\n  // Upgrade 2 twice\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Upgrade,\r\n    upgrades: [{ count: 2, times: 2 }]\r\n  });\r\n  \r\n  // Upgrade 1 three times\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Upgrade,\r\n    upgrades: [{ count: 1, times: 3 }]\r\n  });\r\n\r\n  // TRADE CARDS (20 cards)\r\n  // 2Y -> 2G\r\n  for (let i = 0; i < 2; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Trade,\r\n      gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 },\r\n      receives: { ...emptyCrystals(), [CrystalColor.Green]: 2 }\r\n    });\r\n  }\r\n  \r\n  // 3Y -> 3G\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Green]: 3 }\r\n  });\r\n  \r\n  // 2Y -> 1R\r\n  for (let i = 0; i < 2; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Trade,\r\n      gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 },\r\n      receives: { ...emptyCrystals(), [CrystalColor.Red]: 1 }\r\n    });\r\n  }\r\n  \r\n  // 3Y -> 2R\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Red]: 2 }\r\n  });\r\n  \r\n  // 2G -> 2R\r\n  for (let i = 0; i < 2; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Trade,\r\n      gives: { ...emptyCrystals(), [CrystalColor.Green]: 2 },\r\n      receives: { ...emptyCrystals(), [CrystalColor.Red]: 2 }\r\n    });\r\n  }\r\n  \r\n  // 3G -> 3R\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Green]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Red]: 3 }\r\n  });\r\n  \r\n  // 3Y -> 1B\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Blue]: 1 }\r\n  });\r\n  \r\n  // 2G -> 1B\r\n  for (let i = 0; i < 2; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Trade,\r\n      gives: { ...emptyCrystals(), [CrystalColor.Green]: 2 },\r\n      receives: { ...emptyCrystals(), [CrystalColor.Blue]: 1 }\r\n    });\r\n  }\r\n  \r\n  // 3G -> 2B\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Green]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Blue]: 2 }\r\n  });\r\n  \r\n  // 2R -> 2B\r\n  for (let i = 0; i < 2; i++) {\r\n    cards.push({\r\n      id: `m${idCounter++}`,\r\n      type: MerchantCardType.Trade,\r\n      gives: { ...emptyCrystals(), [CrystalColor.Red]: 2 },\r\n      receives: { ...emptyCrystals(), [CrystalColor.Blue]: 2 }\r\n    });\r\n  }\r\n  \r\n  // 3R -> 3B\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Red]: 3 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Blue]: 3 }\r\n  });\r\n  \r\n  // Mixed trades\r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Green]: 1 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Red]: 3 }\r\n  });\r\n  \r\n  cards.push({\r\n    id: `m${idCounter++}`,\r\n    type: MerchantCardType.Trade,\r\n    gives: { ...emptyCrystals(), [CrystalColor.Yellow]: 1, [CrystalColor.Green]: 2 },\r\n    receives: { ...emptyCrystals(), [CrystalColor.Blue]: 2 }\r\n  });\r\n\r\n  return cards;\r\n}\r\n\r\n/**\r\n * Creates the full point card deck according to the rulebook.\r\n * \r\n * Assumptions: Point values and costs based on Century: Golem Edition.\r\n * Cards range from 6-20 points with varying crystal costs.\r\n * Some cards provide bonus crystals when claimed.\r\n */\r\nfunction createPointCardDeck(): PointCard[] {\r\n  const cards: PointCard[] = [];\r\n  let idCounter = 1;\r\n\r\n  const emptyCrystals = (): CrystalSet => ({\r\n    [CrystalColor.Yellow]: 0,\r\n    [CrystalColor.Green]: 0,\r\n    [CrystalColor.Red]: 0,\r\n    [CrystalColor.Blue]: 0\r\n  });\r\n\r\n  // Low value cards (6-10 points)\r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 6,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 2, [CrystalColor.Red]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 7,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Red]: 2 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 8,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 3, [CrystalColor.Red]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 9,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 3, [CrystalColor.Green]: 1, [CrystalColor.Red]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 10,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 2, [CrystalColor.Red]: 2 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n\r\n  // Medium value cards (11-14 points)\r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 11,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Green]: 2, [CrystalColor.Red]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 12,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 3, [CrystalColor.Red]: 2 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 13,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 3, [CrystalColor.Green]: 2, [CrystalColor.Red]: 1 },\r\n    bonusCrystals: { ...emptyCrystals(), [CrystalColor.Yellow]: 1 }\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 14,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Red]: 3, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n\r\n  // High value cards (15-17 points)\r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 15,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 3, [CrystalColor.Red]: 2, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 16,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Red]: 3, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: { ...emptyCrystals(), [CrystalColor.Green]: 1 }\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 17,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 4, [CrystalColor.Red]: 2, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n\r\n  // Premium value cards (18-20 points)\r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 18,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Red]: 4, [CrystalColor.Blue]: 2 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 19,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 3, [CrystalColor.Red]: 3, [CrystalColor.Blue]: 2 },\r\n    bonusCrystals: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 }\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 20,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Red]: 3, [CrystalColor.Blue]: 3 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n\r\n  // Additional variety cards\r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 11,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 4, [CrystalColor.Green]: 2 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 12,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Red]: 2, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 13,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Green]: 2, [CrystalColor.Red]: 2, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 14,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 3, [CrystalColor.Red]: 3 },\r\n    bonusCrystals: { ...emptyCrystals(), [CrystalColor.Green]: 1 }\r\n  });\r\n  \r\n  cards.push({\r\n    id: `p${idCounter++}`,\r\n    points: 15,\r\n    cost: { ...emptyCrystals(), [CrystalColor.Yellow]: 2, [CrystalColor.Green]: 3, [CrystalColor.Blue]: 1 },\r\n    bonusCrystals: emptyCrystals()\r\n  });\r\n\r\n  return cards;\r\n}\r\n\r\n// ============================================================================\r\n// STARTING CARDS\r\n// ============================================================================\r\n\r\n/**\r\n * Creates the two starting merchant cards every player receives.\r\n * Card 1: Produce 2 yellow crystals\r\n * Card 2: Upgrade 2 crystals once\r\n */\r\nfunction createStartingMerchantCards(playerId: string): MerchantCard[] {\r\n  const emptyCrystals = (): CrystalSet => ({\r\n    [CrystalColor.Yellow]: 0,\r\n    [CrystalColor.Green]: 0,\r\n    [CrystalColor.Red]: 0,\r\n    [CrystalColor.Blue]: 0\r\n  });\r\n\r\n  return [\r\n    {\r\n      id: `start-${playerId}-1`,\r\n      type: MerchantCardType.Produce,\r\n      produces: { ...emptyCrystals(), [CrystalColor.Yellow]: 2 }\r\n    },\r\n    {\r\n      id: `start-${playerId}-2`,\r\n      type: MerchantCardType.Upgrade,\r\n      upgrades: [{ count: 2, times: 1 }]\r\n    }\r\n  ];\r\n}\r\n\r\n// ============================================================================\r\n// MAIN SETUP FUNCTION\r\n// ============================================================================\r\n\r\n/**\r\n * Creates a new game with complete setup following the official rulebook.\r\n * \r\n * Setup order:\r\n * 1. Validate player count (2-5)\r\n * 2. Shuffle Point deck deterministically\r\n * 3. Reveal 5 Point cards in a row\r\n * 4. Place copper coins on rightmost 2 cards, silver on rightmost 1\r\n * 5. Assign starting Merchant cards to each player\r\n * 6. Shuffle remaining Merchant deck\r\n * 7. Reveal 6 Merchant cards in a row\r\n * 8. Give each player a Caravan card (10 capacity)\r\n * 9. Determine first player (player[0] by convention)\r\n * 10. Give starting crystals: 3Y to player 1, 4Y to others\r\n * \r\n * @param players - Array of player inputs with id and name\r\n * @param seed - String seed for deterministic shuffling\r\n * @returns Complete Game state ready to play\r\n * @throws Error if player count is invalid\r\n */\r\nexport function createNewGame(players: PlayerInput[], seed: string): Game {\r\n  // Validate player count\r\n  if (players.length < 2 || players.length > 5) {\r\n    throw new Error(`Invalid player count: ${players.length}. Must be between 2 and 5.`);\r\n  }\r\n\r\n  // Validate unique player IDs\r\n  const idSet = new Set(players.map(p => p.id));\r\n  if (idSet.size !== players.length) {\r\n    throw new Error('Player IDs must be unique');\r\n  }\r\n\r\n  // Create seeded random generator\r\n  const random = createSeededRandom(seed);\r\n\r\n  const emptyCrystals = (): CrystalSet => ({\r\n    [CrystalColor.Yellow]: 0,\r\n    [CrystalColor.Green]: 0,\r\n    [CrystalColor.Red]: 0,\r\n    [CrystalColor.Blue]: 0\r\n  });\r\n\r\n  // STEP 1-2: Create and shuffle Point deck\r\n  const allPointCards = createPointCardDeck();\r\n  const shuffledPointCards = shuffleArray(allPointCards, random);\r\n\r\n  // STEP 3-4: Reveal 5 Point cards and place coins\r\n  const pointCardRowSize = 5;\r\n  const pointCardRow = shuffledPointCards.slice(0, pointCardRowSize).map((card, index) => {\r\n    // Coins on rightmost cards: positions 3 and 4 get copper, position 4 gets silver too\r\n    if (index === 3) {\r\n      return { ...card, points: card.points + COPPER_COIN_VALUE };\r\n    } else if (index === 4) {\r\n      return { ...card, points: card.points + SILVER_COIN_VALUE };\r\n    }\r\n    return card;\r\n  });\r\n\r\n  const pointCardDeck = shuffledPointCards.slice(pointCardRowSize);\r\n\r\n  // STEP 5: Create Merchant deck (excluding starting cards)\r\n  const merchantDeck = createMerchantDeck();\r\n\r\n  // STEP 6: Shuffle Merchant deck\r\n  const shuffledMerchantCards = shuffleArray(merchantDeck, random);\r\n\r\n  // STEP 7: Reveal 6 Merchant cards\r\n  const merchantRowSize = 6;\r\n  const merchantRow = shuffledMerchantCards.slice(0, merchantRowSize);\r\n  const remainingMerchantDeck = shuffledMerchantCards.slice(merchantRowSize);\r\n\r\n  // STEP 8-10: Create players with starting cards and crystals\r\n  const gamePlayers: Player[] = players.map((playerInput, index) => {\r\n    const isFirst = index === 0;\r\n    \r\n    // Starting crystals: first player gets 3Y, others get 4Y\r\n    const startingCrystals = emptyCrystals();\r\n    startingCrystals[CrystalColor.Yellow] = isFirst ? 3 : 4;\r\n\r\n    return {\r\n      id: playerInput.id,\r\n      name: playerInput.name,\r\n      hand: createStartingMerchantCards(playerInput.id),\r\n      playArea: [],\r\n      caravan: startingCrystals,\r\n      pointCards: [],\r\n      score: 0,\r\n      isFirstPlayer: isFirst\r\n    };\r\n  });\r\n\r\n  // Determine end game trigger based on player count\r\n  const config: GameConfig = {\r\n    ...DEFAULT_CONFIG,\r\n    playerCount: players.length,\r\n    pointCardsToTriggerEnd: players.length >= 4 ? 5 : 4\r\n  };\r\n\r\n  // Create complete game state\r\n  // Note: Start in Setup phase - host will transition to Playing when all players connected\r\n  const now = Date.now();\r\n  const game: Game = {\r\n    id: `game-${now}-${seed.substring(0, 8)}`,\r\n    phase: GamePhase.Setup,\r\n    players: gamePlayers,\r\n    currentPlayerIndex: 0,\r\n    merchantDeck: remainingMerchantDeck,\r\n    merchantRow: {\r\n      cards: merchantRow,\r\n      maxSize: merchantRowSize\r\n    },\r\n    pointCardDeck,\r\n    pointCardRow: {\r\n      cards: pointCardRow,\r\n      maxSize: pointCardRowSize\r\n    },\r\n    turnNumber: 1,\r\n    endGameTriggered: false,\r\n    endGameTriggerPlayerIndex: null,\r\n    finalRoundComplete: false,\r\n    winnerId: null,\r\n    createdAt: now,\r\n    updatedAt: now\r\n  };\r\n\r\n  return game;\r\n}\r\n","/**\r\n * PEER-TO-PEER MESSAGE PROTOCOL\r\n * \r\n * This module defines the WebRTC/PeerJS message protocol for host-authoritative\r\n * peer-to-peer multiplayer gameplay.\r\n * \r\n * PROTOCOL RULES:\r\n * 1. All messages are JSON-serializable\r\n * 2. Only HOST may send GAME_STATE messages\r\n * 3. All messages include: gameId, senderId, turnNumber, messageId\r\n * 4. Messages are sent over WebRTC data channels\r\n * \r\n * MESSAGE FLOW:\r\n * ```\r\n * Client → Host:  JOIN_GAME, ACTION_REQUEST\r\n * Host → Client:  GAME_STATE, ACTION_RESULT, ERROR\r\n * Host → All:     GAME_STATE (broadcast)\r\n * ```\r\n */\r\n\r\nimport { Game, GameAction } from '../types/domain';\r\n\r\n// ============================================================================\r\n// BASE MESSAGE\r\n// ============================================================================\r\n\r\n/**\r\n * Base message type with required fields for all P2P messages.\r\n * \r\n * Required Fields:\r\n * - messageId: Unique identifier for this message (for deduplication)\r\n * - gameId: Game session identifier\r\n * - senderId: Peer ID of the sender\r\n * - turnNumber: Current turn number (for ordering/validation)\r\n * - timestamp: Unix epoch milliseconds (for debugging)\r\n */\r\nexport interface BaseP2PMessage {\r\n  messageId: string;\r\n  gameId: string;\r\n  senderId: string;\r\n  turnNumber: number;\r\n  timestamp: number;\r\n}\r\n\r\n// ============================================================================\r\n// MESSAGE TYPES\r\n// ============================================================================\r\n\r\nexport enum P2PMessageType {\r\n  JoinGame = 'JOIN_GAME',\r\n  GameState = 'GAME_STATE',\r\n  ActionRequest = 'ACTION_REQUEST',\r\n  ActionResult = 'ACTION_RESULT',\r\n  Error = 'ERROR'\r\n}\r\n\r\n// ============================================================================\r\n// JOIN_GAME\r\n// ============================================================================\r\n\r\n/**\r\n * JOIN_GAME message\r\n * \r\n * Sent by: Client (non-host peer)\r\n * Sent to: Host\r\n * \r\n * Purpose: Request to join an existing game session\r\n * \r\n * Flow:\r\n * 1. Client establishes WebRTC connection to host\r\n * 2. Client sends JOIN_GAME with player info\r\n * 3. Host validates request\r\n * 4. Host sends GAME_STATE with current state or ERROR\r\n */\r\nexport interface JoinGameMessage extends BaseP2PMessage {\r\n  type: P2PMessageType.JoinGame;\r\n  \r\n  /**\r\n   * Player information for the joining peer.\r\n   * Host will verify this matches a player in the game.\r\n   */\r\n  playerId: string;\r\n  playerName: string;\r\n  \r\n  /**\r\n   * Client version (for compatibility checking).\r\n   * Format: \"major.minor.patch\" (semantic versioning)\r\n   */\r\n  clientVersion: string;\r\n  \r\n  /**\r\n   * Optional: If rejoining after disconnect, last known turn.\r\n   * Host can use this to detect state desync.\r\n   */\r\n  lastKnownTurn?: number;\r\n}\r\n\r\n// ============================================================================\r\n// GAME_STATE\r\n// ============================================================================\r\n\r\n/**\r\n * GAME_STATE message\r\n * \r\n * Sent by: HOST ONLY ⚠️\r\n * Sent to: Individual client or broadcast to all\r\n * \r\n * Purpose: Synchronize game state from authoritative host to clients\r\n * \r\n * SECURITY: Non-host peers MUST NOT send this message type.\r\n * Clients should ignore GAME_STATE from non-host senders.\r\n * \r\n * Flow:\r\n * 1. Host validates action\r\n * 2. Host applies action to state\r\n * 3. Host broadcasts GAME_STATE to all peers\r\n * 4. Clients update their local state\r\n */\r\nexport interface GameStateMessage extends BaseP2PMessage {\r\n  type: P2PMessageType.GameState;\r\n  \r\n  /**\r\n   * Complete authoritative game state.\r\n   * This is the single source of truth.\r\n   */\r\n  game: Game;\r\n  \r\n  /**\r\n   * Reason for state update.\r\n   * Helps clients understand what changed.\r\n   */\r\n  reason: GameStateReason;\r\n  \r\n  /**\r\n   * If reason is ACTION_APPLIED, this is the action that was applied.\r\n   * Clients can use this for optimistic updates or rollback.\r\n   */\r\n  lastAction?: GameAction;\r\n  \r\n  /**\r\n   * If reason is ERROR, this is the error that occurred.\r\n   * Used when host needs to broadcast error affecting game state.\r\n   */\r\n  errorMessage?: string;\r\n  \r\n  /**\r\n   * State hash for verification (recommended for production).\r\n   * Clients can compare this hash to detect desyncs.\r\n   * See stateSync.ts for hash calculation.\r\n   */\r\n  stateHash?: string;\r\n}\r\n\r\n/**\r\n * Reasons why game state is being sent.\r\n */\r\nexport enum GameStateReason {\r\n  /** Initial sync after JOIN_GAME */\r\n  InitialSync = 'INITIAL_SYNC',\r\n  \r\n  /** State update after valid action applied */\r\n  ActionApplied = 'ACTION_APPLIED',\r\n  \r\n  /** State resync requested by client */\r\n  ResyncRequested = 'RESYNC_REQUESTED',\r\n  \r\n  /** State recovery after host migration */\r\n  HostMigration = 'HOST_MIGRATION',\r\n  \r\n  /** Periodic heartbeat sync (optional) */\r\n  PeriodicSync = 'PERIODIC_SYNC',\r\n  \r\n  /** Game ended normally */\r\n  GameEnded = 'GAME_ENDED'\r\n}\r\n\r\n// ============================================================================\r\n// ACTION_REQUEST\r\n// ============================================================================\r\n\r\n/**\r\n * ACTION_REQUEST message\r\n * \r\n * Sent by: Client (non-host peer)\r\n * Sent to: Host\r\n * \r\n * Purpose: Request host to validate and apply an action\r\n * \r\n * Flow:\r\n * 1. Player takes action in UI\r\n * 2. Client sends ACTION_REQUEST to host\r\n * 3. Host validates action\r\n * 4. Host sends ACTION_RESULT (success) or ERROR (failure)\r\n * 5. If success, host broadcasts GAME_STATE to all\r\n */\r\nexport interface ActionRequestMessage extends BaseP2PMessage {\r\n  type: P2PMessageType.ActionRequest;\r\n  \r\n  /**\r\n   * The game action to be validated and applied.\r\n   * Must match one of the GameAction types.\r\n   */\r\n  action: GameAction;\r\n  \r\n  /**\r\n   * Optional: Expected turn number after action.\r\n   * Host can use this to detect race conditions.\r\n   */\r\n  expectedNextTurn?: number;\r\n  \r\n  /**\r\n   * Optional: Client-side optimistic state hash.\r\n   * Host can use this to detect client desync.\r\n   */\r\n  optimisticStateHash?: string;\r\n}\r\n\r\n// ============================================================================\r\n// ACTION_RESULT\r\n// ============================================================================\r\n\r\n/**\r\n * ACTION_RESULT message\r\n * \r\n * Sent by: Host\r\n * Sent to: Client who sent ACTION_REQUEST\r\n * \r\n * Purpose: Confirm action was processed (success or failure)\r\n * \r\n * Note: Even on success, host will also broadcast GAME_STATE.\r\n * This message is just acknowledgment that the request was processed.\r\n * \r\n * Flow:\r\n * 1. Host receives ACTION_REQUEST\r\n * 2. Host validates action\r\n * 3. Host sends ACTION_RESULT to requester\r\n * 4. If valid, host broadcasts GAME_STATE to all\r\n */\r\nexport interface ActionResultMessage extends BaseP2PMessage {\r\n  type: P2PMessageType.ActionResult;\r\n  \r\n  /**\r\n   * ID of the ACTION_REQUEST this is responding to.\r\n   * Clients use this to match requests with responses.\r\n   */\r\n  requestMessageId: string;\r\n  \r\n  /**\r\n   * Whether action was accepted.\r\n   */\r\n  success: boolean;\r\n  \r\n  /**\r\n   * If success, the new turn number after action.\r\n   * Client can verify this matches GAME_STATE broadcast.\r\n   */\r\n  newTurnNumber?: number;\r\n  \r\n  /**\r\n   * If failure, error message explaining why.\r\n   */\r\n  errorMessage?: string;\r\n  \r\n  /**\r\n   * If failure, error code for programmatic handling.\r\n   */\r\n  errorCode?: ActionErrorCode;\r\n}\r\n\r\n/**\r\n * Error codes for action validation failures.\r\n */\r\nexport enum ActionErrorCode {\r\n  /** Not the player's turn */\r\n  NotYourTurn = 'NOT_YOUR_TURN',\r\n  \r\n  /** Invalid action for current game state */\r\n  InvalidAction = 'INVALID_ACTION',\r\n  \r\n  /** Action violates game rules */\r\n  RuleViolation = 'RULE_VIOLATION',\r\n  \r\n  /** Game is not in PLAYING phase */\r\n  GameNotPlaying = 'GAME_NOT_PLAYING',\r\n  \r\n  /** Player not found in game */\r\n  PlayerNotFound = 'PLAYER_NOT_FOUND',\r\n  \r\n  /** Turn number mismatch (stale request) */\r\n  TurnMismatch = 'TURN_MISMATCH',\r\n  \r\n  /** Duplicate action (same messageId seen before) */\r\n  DuplicateAction = 'DUPLICATE_ACTION',\r\n  \r\n  /** Host is busy processing another action */\r\n  HostBusy = 'HOST_BUSY'\r\n}\r\n\r\n// ============================================================================\r\n// ERROR\r\n// ============================================================================\r\n\r\n/**\r\n * ERROR message\r\n * \r\n * Sent by: Host or Client\r\n * Sent to: Specific peer or broadcast\r\n * \r\n * Purpose: Communicate protocol errors, disconnections, or issues\r\n * \r\n * Flow:\r\n * - Host sends ERROR when it can't process a request\r\n * - Client sends ERROR when it detects protocol violation\r\n * - Either can send ERROR before disconnecting\r\n */\r\nexport interface ErrorMessage extends BaseP2PMessage {\r\n  type: P2PMessageType.Error;\r\n  \r\n  /**\r\n   * Error severity level.\r\n   */\r\n  severity: ErrorSeverity;\r\n  \r\n  /**\r\n   * Error category for programmatic handling.\r\n   */\r\n  errorCode: ProtocolErrorCode;\r\n  \r\n  /**\r\n   * Human-readable error message.\r\n   */\r\n  message: string;\r\n  \r\n  /**\r\n   * Optional: ID of message that caused this error.\r\n   */\r\n  causedByMessageId?: string;\r\n  \r\n  /**\r\n   * Optional: Additional context for debugging.\r\n   */\r\n  details?: {\r\n    expectedTurn?: number;\r\n    receivedTurn?: number;\r\n    expectedSender?: string;\r\n    receivedSender?: string;\r\n    [key: string]: any;\r\n  };\r\n  \r\n  /**\r\n   * Whether sender will disconnect after sending this error.\r\n   */\r\n  willDisconnect: boolean;\r\n}\r\n\r\n/**\r\n * Error severity levels.\r\n */\r\nexport enum ErrorSeverity {\r\n  /** Informational, no action needed */\r\n  Info = 'INFO',\r\n  \r\n  /** Warning, might cause issues */\r\n  Warning = 'WARNING',\r\n  \r\n  /** Error, request failed but connection OK */\r\n  Error = 'ERROR',\r\n  \r\n  /** Critical, connection will be terminated */\r\n  Critical = 'CRITICAL'\r\n}\r\n\r\n/**\r\n * Protocol error codes.\r\n */\r\nexport enum ProtocolErrorCode {\r\n  /** Message format invalid (not JSON or missing fields) */\r\n  InvalidMessage = 'INVALID_MESSAGE',\r\n  \r\n  /** Client sent GAME_STATE (only host allowed) */\r\n  UnauthorizedGameState = 'UNAUTHORIZED_GAME_STATE',\r\n  \r\n  /** Message from unknown sender */\r\n  UnknownSender = 'UNKNOWN_SENDER',\r\n  \r\n  /** Game ID doesn't match expected */\r\n  GameIdMismatch = 'GAME_ID_MISMATCH',\r\n  \r\n  /** Turn number too old (duplicate/replay) */\r\n  StaleTurn = 'STALE_TURN',\r\n  \r\n  /** Turn number too new (missed messages) */\r\n  FutureTurn = 'FUTURE_TURN',\r\n  \r\n  /** Client and host versions incompatible */\r\n  VersionMismatch = 'VERSION_MISMATCH',\r\n  \r\n  /** Peer disconnected unexpectedly */\r\n  PeerDisconnected = 'PEER_DISCONNECTED',\r\n  \r\n  /** Host is migrating to another peer */\r\n  HostMigrating = 'HOST_MIGRATING',\r\n  \r\n  /** WebRTC connection failed */\r\n  ConnectionFailed = 'CONNECTION_FAILED',\r\n  \r\n  /** Message size exceeds limit */\r\n  MessageTooLarge = 'MESSAGE_TOO_LARGE',\r\n  \r\n  /** Rate limit exceeded (too many messages) */\r\n  RateLimitExceeded = 'RATE_LIMIT_EXCEEDED'\r\n}\r\n\r\n// ============================================================================\r\n// MESSAGE UNION TYPE\r\n// ============================================================================\r\n\r\n/**\r\n * Discriminated union of all P2P message types.\r\n * \r\n * Use TypeScript's discriminated unions for type-safe message handling:\r\n * \r\n * ```typescript\r\n * function handleMessage(msg: P2PMessage) {\r\n *   switch (msg.type) {\r\n *     case P2PMessageType.JoinGame:\r\n *       // TypeScript knows msg is JoinGameMessage\r\n *       handleJoin(msg);\r\n *       break;\r\n *     case P2PMessageType.GameState:\r\n *       // TypeScript knows msg is GameStateMessage\r\n *       handleState(msg);\r\n *       break;\r\n *     // ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport type P2PMessage =\r\n  | JoinGameMessage\r\n  | GameStateMessage\r\n  | ActionRequestMessage\r\n  | ActionResultMessage\r\n  | ErrorMessage;\r\n\r\n// ============================================================================\r\n// MESSAGE VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validate a P2P message has required base fields.\r\n */\r\nexport function isValidP2PMessage(data: any): data is P2PMessage {\r\n  if (typeof data !== 'object' || data === null) return false;\r\n  \r\n  // Check required base fields\r\n  if (typeof data.messageId !== 'string') return false;\r\n  if (typeof data.gameId !== 'string') return false;\r\n  if (typeof data.senderId !== 'string') return false;\r\n  if (typeof data.turnNumber !== 'number') return false;\r\n  if (typeof data.timestamp !== 'number') return false;\r\n  if (typeof data.type !== 'string') return false;\r\n  \r\n  // Check type is valid\r\n  const validTypes = Object.values(P2PMessageType);\r\n  if (!validTypes.includes(data.type as P2PMessageType)) return false;\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate GAME_STATE message is from host.\r\n * \r\n * SECURITY: Always check this before processing GAME_STATE!\r\n * \r\n * @param message - The message to validate\r\n * @param hostPeerId - The expected host peer ID\r\n * @returns true if message is valid GAME_STATE from host\r\n */\r\nexport function isValidGameStateMessage(\r\n  message: P2PMessage,\r\n  hostPeerId: string\r\n): message is GameStateMessage {\r\n  if (message.type !== P2PMessageType.GameState) return false;\r\n  if (message.senderId !== hostPeerId) {\r\n    console.error('SECURITY: Non-host tried to send GAME_STATE!', {\r\n      sender: message.senderId,\r\n      expectedHost: hostPeerId\r\n    });\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// ============================================================================\r\n// MESSAGE FACTORY\r\n// ============================================================================\r\n\r\n/**\r\n * Factory functions to create properly formatted messages.\r\n */\r\nexport class P2PMessageFactory {\r\n  /**\r\n   * Create JOIN_GAME message.\r\n   */\r\n  static createJoinGame(\r\n    gameId: string,\r\n    senderId: string,\r\n    playerId: string,\r\n    playerName: string,\r\n    clientVersion: string,\r\n    lastKnownTurn?: number\r\n  ): JoinGameMessage {\r\n    return {\r\n      type: P2PMessageType.JoinGame,\r\n      messageId: this.generateMessageId(),\r\n      gameId,\r\n      senderId,\r\n      turnNumber: lastKnownTurn ?? 0,\r\n      timestamp: Date.now(),\r\n      playerId,\r\n      playerName,\r\n      clientVersion,\r\n      lastKnownTurn\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Create GAME_STATE message.\r\n   * Should only be called by host!\r\n   */\r\n  static createGameState(\r\n    gameId: string,\r\n    hostId: string,\r\n    game: Game,\r\n    reason: GameStateReason,\r\n    lastAction?: GameAction,\r\n    errorMessage?: string\r\n  ): GameStateMessage {\r\n    return {\r\n      type: P2PMessageType.GameState,\r\n      messageId: this.generateMessageId(),\r\n      gameId,\r\n      senderId: hostId,\r\n      turnNumber: game.turnNumber,\r\n      timestamp: Date.now(),\r\n      game,\r\n      reason,\r\n      lastAction,\r\n      errorMessage\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Create ACTION_REQUEST message.\r\n   */\r\n  static createActionRequest(\r\n    gameId: string,\r\n    senderId: string,\r\n    turnNumber: number,\r\n    action: GameAction,\r\n    expectedNextTurn?: number\r\n  ): ActionRequestMessage {\r\n    return {\r\n      type: P2PMessageType.ActionRequest,\r\n      messageId: this.generateMessageId(),\r\n      gameId,\r\n      senderId,\r\n      turnNumber,\r\n      timestamp: Date.now(),\r\n      action,\r\n      expectedNextTurn\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Create ACTION_RESULT message.\r\n   */\r\n  static createActionResult(\r\n    gameId: string,\r\n    hostId: string,\r\n    turnNumber: number,\r\n    requestMessageId: string,\r\n    success: boolean,\r\n    newTurnNumber?: number,\r\n    errorMessage?: string,\r\n    errorCode?: ActionErrorCode\r\n  ): ActionResultMessage {\r\n    return {\r\n      type: P2PMessageType.ActionResult,\r\n      messageId: this.generateMessageId(),\r\n      gameId,\r\n      senderId: hostId,\r\n      turnNumber,\r\n      timestamp: Date.now(),\r\n      requestMessageId,\r\n      success,\r\n      newTurnNumber,\r\n      errorMessage,\r\n      errorCode\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Create ERROR message.\r\n   */\r\n  static createError(\r\n    gameId: string,\r\n    senderId: string,\r\n    turnNumber: number,\r\n    severity: ErrorSeverity,\r\n    errorCode: ProtocolErrorCode,\r\n    message: string,\r\n    willDisconnect: boolean = false,\r\n    causedByMessageId?: string,\r\n    details?: any\r\n  ): ErrorMessage {\r\n    return {\r\n      type: P2PMessageType.Error,\r\n      messageId: this.generateMessageId(),\r\n      gameId,\r\n      senderId,\r\n      turnNumber,\r\n      timestamp: Date.now(),\r\n      severity,\r\n      errorCode,\r\n      message,\r\n      causedByMessageId,\r\n      details,\r\n      willDisconnect\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Generate unique message ID.\r\n   * Format: <senderId>_<timestamp>_<random>\r\n   */\r\n  private static generateMessageId(): string {\r\n    const random = Math.random().toString(36).substring(2, 9);\r\n    return `${Date.now()}_${random}`;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// USAGE EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example: Client joins game\r\n * \r\n * ```typescript\r\n * const joinMsg = P2PMessageFactory.createJoinGame(\r\n *   'game_abc123',\r\n *   'peer_xyz',\r\n *   'player_1',\r\n *   'Alice',\r\n *   '1.0.0'\r\n * );\r\n * \r\n * hostConnection.send(JSON.stringify(joinMsg));\r\n * ```\r\n */\r\n\r\n/**\r\n * Example: Host broadcasts state after action\r\n * \r\n * ```typescript\r\n * const stateMsg = P2PMessageFactory.createGameState(\r\n *   game.id,\r\n *   hostPeerId,\r\n *   updatedGame,\r\n *   GameStateReason.ActionApplied,\r\n *   action\r\n * );\r\n * \r\n * // Broadcast to all peers\r\n * peers.forEach(peer => {\r\n *   peer.send(JSON.stringify(stateMsg));\r\n * });\r\n * ```\r\n */\r\n\r\n/**\r\n * Example: Client sends action\r\n * \r\n * ```typescript\r\n * const actionMsg = P2PMessageFactory.createActionRequest(\r\n *   game.id,\r\n *   myPeerId,\r\n *   game.turnNumber,\r\n *   {\r\n *     type: ActionType.PlayMerchantCard,\r\n *     playerId: myPlayerId,\r\n *     timestamp: Date.now(),\r\n *     cardId: 'card_123'\r\n *   }\r\n * );\r\n * \r\n * hostConnection.send(JSON.stringify(actionMsg));\r\n * ```\r\n */\r\n\r\n/**\r\n * Example: Host validates and responds\r\n * \r\n * ```typescript\r\n * hostConnection.on('data', (data) => {\r\n *   const msg: P2PMessage = JSON.parse(data);\r\n *   \r\n *   if (!isValidP2PMessage(msg)) {\r\n *     sendError(ProtocolErrorCode.InvalidMessage);\r\n *     return;\r\n *   }\r\n *   \r\n *   if (msg.type === P2PMessageType.ActionRequest) {\r\n *     const validation = validateAction(game, msg.action);\r\n *     \r\n *     const result = P2PMessageFactory.createActionResult(\r\n *       game.id,\r\n *       hostPeerId,\r\n *       game.turnNumber,\r\n *       msg.messageId,\r\n *       validation.valid,\r\n *       validation.valid ? game.turnNumber + 1 : undefined,\r\n *       validation.valid ? undefined : validation.error,\r\n *       validation.valid ? undefined : ActionErrorCode.InvalidAction\r\n *     );\r\n *     \r\n *     sendToPeer(msg.senderId, result);\r\n *     \r\n *     if (validation.valid) {\r\n *       const newGame = applyAction(game, msg.action);\r\n *       broadcastGameState(newGame, GameStateReason.ActionApplied, msg.action);\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n */\r\n","/**\r\n * State Synchronization Module\r\n * \r\n * Provides safeguards for P2P state consistency:\r\n * - Turn number validation\r\n * - State hash verification\r\n * - Idempotent message handling\r\n * - Re-sync mechanism\r\n * \r\n * Rule: Host state always wins. Clients must request full state on mismatch.\r\n */\r\n\r\nimport { Game } from '../types/domain';\r\nimport { P2PMessage, P2PMessageType, GameStateMessage } from './protocol';\r\n\r\n// ============================================================================\r\n// State Hash Calculation\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate deterministic hash of game state for verification.\r\n * Uses critical fields that must match between host and clients.\r\n */\r\nexport function calculateStateHash(game: Game): string {\r\n  // Include only deterministic fields that affect gameplay\r\n  const criticalState = {\r\n    id: game.id,\r\n    phase: game.phase,\r\n    turnNumber: game.turnNumber,\r\n    currentPlayerIndex: game.currentPlayerIndex,\r\n    \r\n    // Player data (cards, crystals, points)\r\n    players: game.players.map(p => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      hand: p.hand.map(c => c.id).sort(), // Sort for determinism\r\n      playArea: p.playArea.map(c => c.id).sort(),\r\n      caravan: { ...p.caravan }, // Crystal counts\r\n      pointCards: p.pointCards.map(c => c.id).sort(),\r\n      score: p.score,\r\n      isFirstPlayer: p.isFirstPlayer\r\n    })),\r\n    \r\n    // Merchant row state\r\n    merchantRow: game.merchantRow.cards.map(c => c ? c.id : null),\r\n    \r\n    // Deck sizes (not contents, for security)\r\n    merchantDeckSize: game.merchantDeck.length,\r\n    pointCardDeckSize: game.pointCardDeck.length,\r\n    \r\n    // Point cards visible\r\n    pointCardRow: game.pointCardRow.cards.map(c => c ? c.id : null),\r\n    \r\n    // End game state\r\n    endGameTriggered: game.endGameTriggered,\r\n    endGameTriggerPlayerIndex: game.endGameTriggerPlayerIndex,\r\n    finalRoundComplete: game.finalRoundComplete,\r\n    winnerId: game.winnerId\r\n  };\r\n  \r\n  // Simple hash: stringify and use a basic hash function\r\n  const json = JSON.stringify(criticalState);\r\n  return simpleHash(json);\r\n}\r\n\r\n/**\r\n * Simple string hash for state verification.\r\n * Not cryptographic - just for detecting desyncs.\r\n */\r\nfunction simpleHash(str: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str.charCodeAt(i);\r\n    hash = ((hash << 5) - hash) + char;\r\n    hash = hash & hash; // Convert to 32-bit integer\r\n  }\r\n  return Math.abs(hash).toString(36).padStart(8, '0');\r\n}\r\n\r\n// ============================================================================\r\n// Turn Number Validation\r\n// ============================================================================\r\n\r\nexport interface TurnValidationResult {\r\n  valid: boolean;\r\n  action: 'accept' | 'ignore' | 'resync';\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * Validate turn number of incoming message against current state.\r\n * \r\n * Rules:\r\n * - Exact match: Accept\r\n * - One behind: Accept (tolerate minor lag)\r\n * - Two or more behind: Ignore (too stale)\r\n * - Ahead: Request resync (missed updates)\r\n */\r\nexport function validateTurnNumber(\r\n  messageTurn: number,\r\n  currentTurn: number\r\n): TurnValidationResult {\r\n  const diff = messageTurn - currentTurn;\r\n  \r\n  if (diff === 0) {\r\n    // Exact match\r\n    return { valid: true, action: 'accept' };\r\n  }\r\n  \r\n  if (diff === -1) {\r\n    // One turn behind - tolerate network lag\r\n    return { valid: true, action: 'accept', reason: 'Tolerated lag' };\r\n  }\r\n  \r\n  if (diff < -1) {\r\n    // Too old - ignore\r\n    return {\r\n      valid: false,\r\n      action: 'ignore',\r\n      reason: `Message too old: turn ${messageTurn} vs current ${currentTurn}`\r\n    };\r\n  }\r\n  \r\n  // diff > 0: Message from future\r\n  return {\r\n    valid: false,\r\n    action: 'resync',\r\n    reason: `Missed updates: message at turn ${messageTurn}, we're at ${currentTurn}`\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Idempotent Message Handling\r\n// ============================================================================\r\n\r\nexport class MessageDeduplicator {\r\n  private seenMessages: Set<string>;\r\n  private messageTimestamps: Map<string, number>;\r\n  private readonly maxAge: number; // milliseconds\r\n  private readonly maxSize: number;\r\n  \r\n  constructor(maxAge: number = 60000, maxSize: number = 1000) {\r\n    this.seenMessages = new Set();\r\n    this.messageTimestamps = new Map();\r\n    this.maxAge = maxAge;\r\n    this.maxSize = maxSize;\r\n  }\r\n  \r\n  /**\r\n   * Check if message has been seen before (idempotency).\r\n   * Returns true if message is NEW (should be processed).\r\n   * Returns false if message is DUPLICATE (should be ignored).\r\n   */\r\n  shouldProcess(message: P2PMessage): boolean {\r\n    const msgId = message.messageId;\r\n    \r\n    if (this.seenMessages.has(msgId)) {\r\n      console.log(`[Dedup] Ignoring duplicate message: ${msgId}`);\r\n      return false;\r\n    }\r\n    \r\n    // Add to seen set\r\n    this.seenMessages.add(msgId);\r\n    this.messageTimestamps.set(msgId, message.timestamp);\r\n    \r\n    // Cleanup old messages\r\n    this.cleanup();\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Remove old messages from deduplication cache.\r\n   */\r\n  private cleanup(): void {\r\n    if (this.seenMessages.size < this.maxSize) {\r\n      return;\r\n    }\r\n    \r\n    const now = Date.now();\r\n    const toRemove: string[] = [];\r\n    \r\n    this.messageTimestamps.forEach((timestamp, msgId) => {\r\n      if (now - timestamp > this.maxAge) {\r\n        toRemove.push(msgId);\r\n      }\r\n    });\r\n    \r\n    toRemove.forEach(msgId => {\r\n      this.seenMessages.delete(msgId);\r\n      this.messageTimestamps.delete(msgId);\r\n    });\r\n    \r\n    console.log(`[Dedup] Cleaned up ${toRemove.length} old messages`);\r\n  }\r\n  \r\n  /**\r\n   * Clear all cached messages (e.g., on game restart).\r\n   */\r\n  clear(): void {\r\n    this.seenMessages.clear();\r\n    this.messageTimestamps.clear();\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// State Verification (Client-side)\r\n// ============================================================================\r\n\r\nexport interface StateVerificationResult {\r\n  valid: boolean;\r\n  localHash: string;\r\n  remoteHash: string;\r\n  turnMatches: boolean;\r\n  action: 'accept' | 'resync';\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * Verify received GAME_STATE against local state.\r\n * Called by clients when receiving state from host.\r\n * \r\n * Rule: If mismatch detected, client MUST request full resync.\r\n */\r\nexport function verifyGameState(\r\n  receivedState: GameStateMessage,\r\n  localGame: Game | null,\r\n  hostPeerId: string\r\n): StateVerificationResult {\r\n  // Security: Verify sender is host\r\n  if (receivedState.senderId !== hostPeerId) {\r\n    console.error('[Security] Non-host tried to send GAME_STATE!');\r\n    return {\r\n      valid: false,\r\n      localHash: '',\r\n      remoteHash: '',\r\n      turnMatches: false,\r\n      action: 'resync',\r\n      reason: 'SECURITY: Unauthorized sender'\r\n    };\r\n  }\r\n  \r\n  // First state received - always accept\r\n  if (!localGame) {\r\n    return {\r\n      valid: true,\r\n      localHash: '',\r\n      remoteHash: receivedState.stateHash || 'none',\r\n      turnMatches: true,\r\n      action: 'accept',\r\n      reason: 'Initial state'\r\n    };\r\n  }\r\n  \r\n  // Calculate hashes\r\n  const localHash = calculateStateHash(localGame);\r\n  const remoteHash = receivedState.stateHash || '';\r\n  \r\n  // Check turn number\r\n  const turnValidation = validateTurnNumber(\r\n    receivedState.turnNumber,\r\n    localGame.turnNumber\r\n  );\r\n  \r\n  if (!turnValidation.valid && turnValidation.action === 'ignore') {\r\n    return {\r\n      valid: false,\r\n      localHash,\r\n      remoteHash,\r\n      turnMatches: false,\r\n      action: 'resync',\r\n      reason: turnValidation.reason\r\n    };\r\n  }\r\n  \r\n  // If we're ahead of received state, something is wrong\r\n  if (receivedState.turnNumber < localGame.turnNumber) {\r\n    console.warn('[StateSync] Received older state from host - requesting resync');\r\n    return {\r\n      valid: false,\r\n      localHash,\r\n      remoteHash,\r\n      turnMatches: false,\r\n      action: 'resync',\r\n      reason: `Host sent older state: ${receivedState.turnNumber} < ${localGame.turnNumber}`\r\n    };\r\n  }\r\n  \r\n  // If turn numbers match, verify hash\r\n  if (receivedState.turnNumber === localGame.turnNumber) {\r\n    if (!remoteHash || remoteHash === localHash) {\r\n      return {\r\n        valid: true,\r\n        localHash,\r\n        remoteHash,\r\n        turnMatches: true,\r\n        action: 'accept'\r\n      };\r\n    } else {\r\n      // HASH MISMATCH - desync detected!\r\n      console.error('[StateSync] Hash mismatch detected!');\r\n      console.error(`  Local:  ${localHash}`);\r\n      console.error(`  Remote: ${remoteHash}`);\r\n      return {\r\n        valid: false,\r\n        localHash,\r\n        remoteHash,\r\n        turnMatches: true,\r\n        action: 'resync',\r\n        reason: `State hash mismatch at turn ${localGame.turnNumber}`\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Host is ahead - accept update\r\n  return {\r\n    valid: true,\r\n    localHash,\r\n    remoteHash,\r\n    turnMatches: false,\r\n    action: 'accept',\r\n    reason: `Catching up: ${localGame.turnNumber} → ${receivedState.turnNumber}`\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Re-sync Mechanism\r\n// ============================================================================\r\n\r\n/**\r\n * Request types for state synchronization.\r\n */\r\nexport enum ResyncReason {\r\n  HashMismatch = 'HASH_MISMATCH',\r\n  MissedUpdates = 'MISSED_UPDATES',\r\n  TurnMismatch = 'TURN_MISMATCH',\r\n  ConnectionRecovered = 'CONNECTION_RECOVERED',\r\n  ManualRequest = 'MANUAL_REQUEST'\r\n}\r\n\r\n/**\r\n * Resync request message (Client → Host).\r\n * Client requests full state when detecting inconsistency.\r\n */\r\nexport interface ResyncRequestMessage {\r\n  type: 'RESYNC_REQUEST';\r\n  messageId: string;\r\n  gameId: string;\r\n  senderId: string;\r\n  turnNumber: number;\r\n  timestamp: number;\r\n  reason: ResyncReason;\r\n  clientTurnNumber: number;\r\n  clientStateHash?: string;\r\n  lastReceivedTurn: number;\r\n}\r\n\r\n/**\r\n * Resync response message (Host → Client).\r\n * Host sends full authoritative state.\r\n */\r\nexport interface ResyncResponseMessage extends GameStateMessage {\r\n  isResyncResponse: true;\r\n  resyncRequestId: string; // ID of ResyncRequestMessage\r\n}\r\n\r\n/**\r\n * Create a resync request message.\r\n */\r\nexport function createResyncRequest(\r\n  gameId: string,\r\n  senderId: string,\r\n  reason: ResyncReason,\r\n  currentGame: Game | null,\r\n  lastReceivedTurn: number\r\n): ResyncRequestMessage {\r\n  const turnNumber = currentGame?.turnNumber ?? 0;\r\n  const stateHash = currentGame ? calculateStateHash(currentGame) : undefined;\r\n  \r\n  return {\r\n    type: 'RESYNC_REQUEST',\r\n    messageId: `resync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    gameId,\r\n    senderId,\r\n    turnNumber,\r\n    timestamp: Date.now(),\r\n    reason,\r\n    clientTurnNumber: turnNumber,\r\n    clientStateHash: stateHash,\r\n    lastReceivedTurn\r\n  };\r\n}\r\n\r\n/**\r\n * Client-side resync manager.\r\n * Handles detection and recovery from desyncs.\r\n */\r\nexport class ClientResyncManager {\r\n  private pendingResync: boolean = false;\r\n  private lastResyncRequest: number = 0;\r\n  private readonly minResyncInterval: number = 2000; // 2 seconds between resyncs\r\n  \r\n  /**\r\n   * Check if client should request resync.\r\n   * Prevents spam requests.\r\n   */\r\n  shouldRequestResync(): boolean {\r\n    if (this.pendingResync) {\r\n      console.log('[Resync] Already waiting for resync response');\r\n      return false;\r\n    }\r\n    \r\n    const now = Date.now();\r\n    if (now - this.lastResyncRequest < this.minResyncInterval) {\r\n      console.log('[Resync] Too soon since last request');\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Mark resync as requested.\r\n   */\r\n  markResyncRequested(): void {\r\n    this.pendingResync = true;\r\n    this.lastResyncRequest = Date.now();\r\n  }\r\n  \r\n  /**\r\n   * Mark resync as completed.\r\n   */\r\n  markResyncCompleted(): void {\r\n    this.pendingResync = false;\r\n    console.log('[Resync] State synchronized successfully');\r\n  }\r\n  \r\n  /**\r\n   * Reset resync state (e.g., on disconnect).\r\n   */\r\n  reset(): void {\r\n    this.pendingResync = false;\r\n    this.lastResyncRequest = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Host-side resync handler.\r\n * Responds to client resync requests.\r\n */\r\nexport class HostResyncManager {\r\n  private resyncCount: Map<string, number> = new Map(); // peerId -> count\r\n  private readonly maxResyncsPerMinute: number = 10;\r\n  \r\n  /**\r\n   * Check if client is allowed to resync (rate limiting).\r\n   */\r\n  canClientResync(clientPeerId: string): boolean {\r\n    const count = this.resyncCount.get(clientPeerId) || 0;\r\n    return count < this.maxResyncsPerMinute;\r\n  }\r\n  \r\n  /**\r\n   * Record resync request from client.\r\n   */\r\n  recordResync(clientPeerId: string): void {\r\n    const count = this.resyncCount.get(clientPeerId) || 0;\r\n    this.resyncCount.set(clientPeerId, count + 1);\r\n    \r\n    console.log(`[Resync] Client ${clientPeerId} requested resync (${count + 1}/${this.maxResyncsPerMinute})`);\r\n  }\r\n  \r\n  /**\r\n   * Reset resync counters (called every minute).\r\n   */\r\n  resetCounters(): void {\r\n    this.resyncCount.clear();\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Complete State Sync Workflow\r\n// ============================================================================\r\n\r\n/**\r\n * Example client-side workflow for handling GAME_STATE messages.\r\n */\r\nexport class ClientStateSyncHandler {\r\n  private localGame: Game | null = null;\r\n  private hostPeerId: string;\r\n  private deduplicator: MessageDeduplicator;\r\n  private resyncManager: ClientResyncManager;\r\n  \r\n  constructor(hostPeerId: string) {\r\n    this.hostPeerId = hostPeerId;\r\n    this.deduplicator = new MessageDeduplicator();\r\n    this.resyncManager = new ClientResyncManager();\r\n  }\r\n  \r\n  /**\r\n   * Handle incoming GAME_STATE message with full validation.\r\n   */\r\n  handleGameState(message: GameStateMessage): 'applied' | 'resync_needed' | 'ignored' {\r\n    // Step 1: Idempotency check\r\n    if (!this.deduplicator.shouldProcess(message)) {\r\n      return 'ignored';\r\n    }\r\n    \r\n    // Step 2: Verify state\r\n    const verification = verifyGameState(message, this.localGame, this.hostPeerId);\r\n    \r\n    if (!verification.valid) {\r\n      console.error('[StateSync] State verification failed:', verification.reason);\r\n      \r\n      // Request resync if not already pending\r\n      if (this.resyncManager.shouldRequestResync()) {\r\n        const reason = verification.turnMatches\r\n          ? ResyncReason.HashMismatch\r\n          : ResyncReason.TurnMismatch;\r\n        \r\n        this.requestResync(reason, message.turnNumber);\r\n      }\r\n      \r\n      return 'resync_needed';\r\n    }\r\n    \r\n    // Step 3: Apply state (HOST STATE ALWAYS WINS)\r\n    this.localGame = message.game;\r\n    \r\n    // If this was a resync response, mark complete\r\n    if ((message as ResyncResponseMessage).isResyncResponse) {\r\n      this.resyncManager.markResyncCompleted();\r\n    }\r\n    \r\n    console.log(`[StateSync] Applied state at turn ${message.turnNumber}, hash: ${verification.remoteHash}`);\r\n    return 'applied';\r\n  }\r\n  \r\n  /**\r\n   * Request full state resync from host.\r\n   */\r\n  private requestResync(reason: ResyncReason, lastReceivedTurn: number): void {\r\n    this.resyncManager.markResyncRequested();\r\n    \r\n    const request = createResyncRequest(\r\n      this.localGame?.id || '',\r\n      'my-peer-id', // Replace with actual peer ID\r\n      reason,\r\n      this.localGame,\r\n      lastReceivedTurn\r\n    );\r\n    \r\n    console.warn('[StateSync] Requesting full state resync:', reason);\r\n    // Send request to host via WebRTC\r\n    // hostConnection.send(request);\r\n  }\r\n  \r\n  /**\r\n   * Get current local game state.\r\n   */\r\n  getLocalGame(): Game | null {\r\n    return this.localGame;\r\n  }\r\n  \r\n  /**\r\n   * Reset sync state (on disconnect/reconnect).\r\n   */\r\n  reset(): void {\r\n    this.deduplicator.clear();\r\n    this.resyncManager.reset();\r\n  }\r\n}\r\n\r\n/**\r\n * Example host-side workflow for handling resync requests.\r\n */\r\nexport class HostStateSyncHandler {\r\n  private game: Game;\r\n  private resyncManager: HostResyncManager;\r\n  \r\n  constructor(game: Game) {\r\n    this.game = game;\r\n    this.resyncManager = new HostResyncManager();\r\n    \r\n    // Reset rate limits every minute\r\n    setInterval(() => {\r\n      this.resyncManager.resetCounters();\r\n    }, 60000);\r\n  }\r\n  \r\n  /**\r\n   * Handle resync request from client.\r\n   */\r\n  handleResyncRequest(\r\n    request: ResyncRequestMessage,\r\n    clientPeerId: string\r\n  ): ResyncResponseMessage | null {\r\n    // Check rate limits\r\n    if (!this.resyncManager.canClientResync(clientPeerId)) {\r\n      console.warn(`[Resync] Rate limit exceeded for client ${clientPeerId}`);\r\n      return null;\r\n    }\r\n    \r\n    this.resyncManager.recordResync(clientPeerId);\r\n    \r\n    // Log resync reason for monitoring\r\n    console.log(`[Resync] Client ${clientPeerId} reason: ${request.reason}`);\r\n    console.log(`  Client turn: ${request.clientTurnNumber}, Host turn: ${this.game.turnNumber}`);\r\n    if (request.clientStateHash) {\r\n      const hostHash = calculateStateHash(this.game);\r\n      console.log(`  Client hash: ${request.clientStateHash}`);\r\n      console.log(`  Host hash:   ${hostHash}`);\r\n    }\r\n    \r\n    // Create resync response with full state\r\n    const response: ResyncResponseMessage = {\r\n      type: P2PMessageType.GameState,\r\n      messageId: `resync_resp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      gameId: this.game.id,\r\n      senderId: 'host-peer-id', // Replace with actual host peer ID\r\n      turnNumber: this.game.turnNumber,\r\n      timestamp: Date.now(),\r\n      game: this.game,\r\n      reason: 'RESYNC_RESPONSE' as any,\r\n      stateHash: calculateStateHash(this.game),\r\n      isResyncResponse: true,\r\n      resyncRequestId: request.messageId\r\n    };\r\n    \r\n    return response;\r\n  }\r\n  \r\n  /**\r\n   * Update game state and calculate hash for next broadcast.\r\n   */\r\n  updateGame(newGame: Game): string {\r\n    this.game = newGame;\r\n    return calculateStateHash(newGame);\r\n  }\r\n}\r\n","/**\r\n * Browser-Only P2P Room Creation\r\n * \r\n * Pure client-side implementation using PeerJS for LAN multiplayer.\r\n * One browser acts as the authoritative host with no backend server.\r\n * \r\n * Features:\r\n * - Short room codes (6 characters)\r\n * - In-memory game state storage\r\n * - WebRTC peer connections via PeerJS\r\n * - Integration with existing game engine\r\n * \r\n * Usage:\r\n *   const room = new P2PGameRoom();\r\n *   await room.createRoom(['Alice', 'Bob', 'Charlie']);\r\n *   console.log('Share room code:', room.getRoomCode());\r\n */\r\n\r\n// @ts-ignore - PeerJS types installed separately\r\nimport Peer, { DataConnection } from 'peerjs';\r\nimport { Game, GameAction, GamePhase } from '../types/domain';\r\nimport { createNewGame, PlayerInput } from '../setup/gameSetup';\r\nimport { validateAction } from '../engine/validation';\r\nimport { applyAction } from '../engine/actionResolver';\r\nimport { advanceTurn } from '../engine/turnSystem';\r\nimport { finalizeGame } from '../engine/endgame';\r\nimport {\r\n  HostStateSyncHandler,\r\n  calculateStateHash,\r\n  ResyncRequestMessage\r\n} from './stateSync';\r\nimport {\r\n  P2PMessage,\r\n  P2PMessageType,\r\n  JoinGameMessage,\r\n  ActionRequestMessage,\r\n  P2PMessageFactory,\r\n  GameStateMessage\r\n} from './protocol';\r\nimport { MessageDeduplicator } from './stateSync';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface RoomConfig {\r\n  playerNames: string[];\r\n  seed?: string;\r\n  observerMode?: boolean;\r\n}\r\n\r\nexport interface RoomInfo {\r\n  roomCode: string;\r\n  gameId: string;\r\n  hostPeerId: string;\r\n  createdAt: number;\r\n  playerCount: number;\r\n  connectedPlayers: number;\r\n  gamePhase: GamePhase;\r\n}\r\n\r\nexport interface ConnectedPlayer {\r\n  playerId: string;\r\n  playerName: string;\r\n  peerId: string;\r\n  connected: boolean;\r\n  connectedAt: number;\r\n  disconnectTime?: number;\r\n}\r\n\r\nexport type RoomEventMap = {\r\n  'room-created': (info: RoomInfo) => void;\r\n  'room-error': (error: Error) => void;\r\n  'peer-connecting': (peerId: string) => void;\r\n  'peer-connected': (player: ConnectedPlayer) => void;\r\n  'peer-disconnected': (peerId: string, playerName: string) => void;\r\n  'peer-reconnected': (peerId: string, playerName: string) => void;\r\n  'action-processed': (action: GameAction, success: boolean) => void;\r\n  'game-state-updated': (game: Game) => void;\r\n  'turn-auto-skipped': (playerId: string, playerName: string) => void;\r\n  'late-joiner-rejected': (peerId: string, playerName: string) => void;\r\n};\r\n\r\n// ============================================================================\r\n// BROWSER P2P ROOM (HOST)\r\n// ============================================================================\r\n\r\n/**\r\n * P2P Game Room - Browser-only host implementation.\r\n * \r\n * This class manages:\r\n * - Room creation with short codes\r\n * - PeerJS host initialization\r\n * - Game engine lifecycle\r\n * - Peer connection management\r\n * - Authoritative state storage\r\n * \r\n * NO SERVER REQUIRED - runs entirely in the browser.\r\n */\r\nexport class P2PGameRoom {\r\n  // PeerJS\r\n  private peer: Peer | null = null;\r\n  private hostPeerId: string = '';\r\n  private roomCode: string = '';\r\n  \r\n  // Game state (authoritative)\r\n  private game: Game | null = null;\r\n  private syncHandler: HostStateSyncHandler | null = null;\r\n  \r\n  // Connected peers\r\n  private connectedPeers: Map<string, DataConnection> = new Map();\r\n  private playerConnections: Map<string, ConnectedPlayer> = new Map(); // playerId -> info\r\n  private observers: Set<string> = new Set(); // Observer peer IDs\r\n  \r\n  // Configuration\r\n  private config: RoomConfig | null = null;\r\n  private observerModeEnabled: boolean = false;\r\n  \r\n  // Safeguards\r\n  private deduplicator: MessageDeduplicator;\r\n  private autoSkipTimers: Map<string, NodeJS.Timeout> = new Map();\r\n  private readonly PEER_RECONNECT_GRACE_PERIOD = 15000; // 15 seconds\r\n  private isProcessingAction: boolean = false; // Race condition protection\r\n  \r\n  // Events\r\n  private eventListeners: Map<keyof RoomEventMap, Set<Function>> = new Map();\r\n  \r\n  constructor() {\r\n    this.deduplicator = new MessageDeduplicator();\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // ROOM CREATION\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Create a new game room (browser becomes host).\r\n   * \r\n   * @param playerNames - Array of player names (2-5 players)\r\n   * @param seed - Optional seed for deterministic setup\r\n   * @param observerMode - Allow late joiners as observers\r\n   * @returns Promise<RoomInfo> - Room details to share with players\r\n   */\r\n  async createRoom(\r\n    playerNames: string[],\r\n    seed?: string,\r\n    observerMode: boolean = false\r\n  ): Promise<RoomInfo> {\r\n    if (playerNames.length < 2 || playerNames.length > 5) {\r\n      throw new Error('Invalid player count. Must be 2-5 players.');\r\n    }\r\n    \r\n    // Prevent duplicate room creation\r\n    if (this.peer) {\r\n      throw new Error('Room already created. Cannot create multiple rooms.');\r\n    }\r\n    \r\n    try {\r\n      // Step 1: Generate short room code\r\n      this.roomCode = this.generateRoomCode();\r\n      \r\n      // Step 2: Create game via engine (NO BACKEND)\r\n      const players: PlayerInput[] = playerNames.map((name, idx) => ({\r\n        id: `player_${idx}`,\r\n        name: name\r\n      }));\r\n      this.game = createNewGame(players, seed || this.generateSeed());\r\n      this.syncHandler = new HostStateSyncHandler(this.game);\r\n      \r\n      // Step 3: Initialize PeerJS host with predictable ID format\r\n      this.hostPeerId = `boardgame-${this.roomCode.toLowerCase()}`;\r\n      await this.initializePeerHost();\r\n      \r\n      // Step 4: Store config\r\n      this.config = { playerNames, seed, observerMode };\r\n      this.observerModeEnabled = observerMode;\r\n      \r\n      // Step 5: Create room info\r\n      const roomInfo: RoomInfo = {\r\n        roomCode: this.roomCode,\r\n        gameId: this.game.id,\r\n        hostPeerId: this.hostPeerId,\r\n        createdAt: Date.now(),\r\n        playerCount: playerNames.length,\r\n        connectedPlayers: 1, // Host counts as connected\r\n        gamePhase: this.game.phase\r\n      };\r\n      \r\n      this.emit('room-created', roomInfo);\r\n      \r\n      // Step 6: Save room info in browser storage\r\n      this.saveRoomToLocalStorage(roomInfo);\r\n      \r\n      return roomInfo;\r\n      \r\n    } catch (error) {\r\n      console.error('[Room] Failed to create:', error);\r\n      this.emit('room-error', error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Generate a short, human-readable room code.\r\n   * Format: 6 uppercase alphanumeric characters (e.g., \"A3F9K2\")\r\n   * Avoids confusing characters: O, 0, I, 1, L\r\n   */\r\n  private generateRoomCode(): string {\r\n    const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789'; // No O,0,I,1,L\r\n    let code = '';\r\n    \r\n    for (let i = 0; i < 6; i++) {\r\n      const randomIndex = Math.floor(Math.random() * chars.length);\r\n      code += chars[randomIndex];\r\n    }\r\n    \r\n    return code;\r\n  }\r\n  \r\n  /**\r\n   * Generate a random seed for game setup.\r\n   */\r\n  private generateSeed(): string {\r\n    return `${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\r\n  }\r\n  \r\n  /**\r\n   * Initialize PeerJS as host.\r\n   * Uses room code as part of peer ID for easy discovery.\r\n   */\r\n  private async initializePeerHost(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      // Set a timeout for initialization\r\n      const timeout = setTimeout(() => {\r\n        if (this.peer) {\r\n          this.peer.destroy();\r\n        }\r\n        reject(new Error('PeerJS initialization timeout (10s). Please check your internet connection and try again.'));\r\n      }, 10000);\r\n      \r\n      // Create peer - use async-games working configuration\r\n      try {\r\n        console.log('[Room] Creating Peer:', this.hostPeerId);\r\n        this.peer = new Peer(this.hostPeerId, {\r\n          host: '0.peerjs.com',\r\n          port: 443,\r\n          path: '/',\r\n          secure: true,\r\n          debug: 1,\r\n          config: {\r\n            iceServers: [\r\n              { urls: 'stun:stun.l.google.com:19302' },\r\n              { urls: 'stun:global.stun.twilio.com:3478' },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:80',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:443',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:443?transport=tcp',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              }\r\n            ]\r\n          }\r\n        });\r\n        console.log('[Room] Peer instance created, waiting for signaling server...');\r\n      } catch (err) {\r\n        clearTimeout(timeout);\r\n        reject(new Error(`Failed to create Peer: ${err}`));\r\n        return;\r\n      }\r\n      \r\n      // Attach connection listener BEFORE 'open' to avoid race condition\r\n      this.peer.on('connection', (conn: DataConnection) => {\r\n        console.log('[Room] >>> Incoming connection from:', conn.peer);\r\n        this.handleIncomingConnection(conn);\r\n      });\r\n      \r\n      this.peer.on('open', (id: string) => {\r\n        clearTimeout(timeout);\r\n        console.log('[Room] ✓ Peer opened, ID:', id);\r\n        console.log('[Room] ✓ Connected to signaling server');\r\n        console.log('[Room] ✓ Ready to accept connections');\r\n        this.setupPeerListeners();\r\n        resolve();\r\n      });\r\n      \r\n      this.peer.on('error', (err: any) => {\r\n        clearTimeout(timeout);\r\n        console.error('[Room] ✗ PeerJS error:', err);\r\n        const errorMsg = err.type ? `${err.type}: ${err.message || err}` : String(err);\r\n        reject(new Error(`Signaling server error: ${errorMsg}. Try refreshing the page.`));\r\n      });\r\n      \r\n      this.peer.on('disconnected', () => {\r\n        console.warn('[Room] PeerJS disconnected from signaling server');\r\n        // Attempt reconnect\r\n        this.peer?.reconnect();\r\n      });\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Save room info to localStorage for recovery.\r\n   */\r\n  private saveRoomToLocalStorage(info: RoomInfo): void {\r\n    try {\r\n      // Check if localStorage is available (browser environment)\r\n      if (typeof localStorage === 'undefined') {\r\n        console.warn('[Room] localStorage not available');\r\n        return;\r\n      }\r\n      \r\n      const roomData = {\r\n        ...info,\r\n        game: this.game,\r\n        savedAt: Date.now()\r\n      };\r\n      \r\n      localStorage.setItem(\r\n        `p2p_room_${this.roomCode}`,\r\n        JSON.stringify(roomData)\r\n      );\r\n    } catch (err) {\r\n      console.warn('[Room] Failed to save to localStorage:', err);\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // PEER CONNECTION MANAGEMENT\r\n  // ==========================================================================\r\n  \r\n  private setupPeerListeners(): void {\r\n    // Already set up in initializePeerHost\r\n  }\r\n  \r\n  /**\r\n   * Handle incoming peer connection.\r\n   */\r\n  private handleIncomingConnection(conn: DataConnection): void {\r\n    console.log('[Room] Processing incoming connection from:', conn.peer);\r\n    this.emit('peer-connecting', conn.peer);\r\n    \r\n    // Wait for connection to open\r\n    conn.on('open', () => {\r\n      console.log('[Room] ✓ Connection opened with:', conn.peer);\r\n      this.connectedPeers.set(conn.peer, conn);\r\n      this.setupConnectionListeners(conn);\r\n    });\r\n    \r\n    conn.on('error', (err: Error) => {\r\n      console.error('[Room] ✗ Connection error with', conn.peer, ':', err);\r\n    });\r\n    \r\n    conn.on('close', () => {\r\n      console.log('[Room] Connection closed:', conn.peer);\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Set up listeners for a peer connection.\r\n   */\r\n  private setupConnectionListeners(conn: DataConnection): void {\r\n    console.log('[Room] Attaching message handlers for:', conn.peer);\r\n    \r\n    // Receive messages\r\n    conn.on('data', (data: any) => {\r\n      console.log('[Room] <<< Received message from', conn.peer, 'type:', (data as P2PMessage).type);\r\n      this.handlePeerMessage(data as P2PMessage, conn.peer);\r\n    });\r\n    \r\n    // Handle disconnect\r\n    conn.on('close', () => {\r\n      console.log('[Room] ✗ Peer disconnected:', conn.peer);\r\n      this.handlePeerDisconnect(conn.peer);\r\n    });\r\n    \r\n    conn.on('error', (err: Error) => {\r\n      console.error('[Room] ✗ Peer error:', conn.peer, err);\r\n    });\r\n    \r\n    console.log('[Room] ✓ Message handlers ready for:', conn.peer);\r\n  }\r\n  \r\n  /**\r\n   * Route incoming messages from peers.\r\n   */\r\n  private handlePeerMessage(message: P2PMessage, peerId: string): void {\r\n    // Idempotency check (Layer 1)\r\n    if (!this.deduplicator.shouldProcess(message)) {\r\n      return;\r\n    }\r\n    \r\n    switch (message.type) {\r\n      case P2PMessageType.JoinGame:\r\n        this.handleJoinRequest(message as JoinGameMessage, peerId);\r\n        break;\r\n        \r\n      case P2PMessageType.ActionRequest:\r\n        this.handleActionRequest(message as ActionRequestMessage, peerId);\r\n        break;\r\n        \r\n      default:\r\n        // Check for custom message types\r\n        if ((message as any).type === 'RESYNC_REQUEST') {\r\n          this.handleResyncRequest(message as any, peerId);\r\n        } else {\r\n          console.warn('[Room] Unknown message type:', message.type);\r\n        }\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // JOIN HANDLING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle JOIN_GAME request from peer.\r\n   * Validates player and either accepts or rejects.\r\n   */\r\n  private handleJoinRequest(msg: JoinGameMessage, peerId: string): void {\r\n    if (!this.game) {\r\n      this.sendError(peerId, 'GAME_NOT_FOUND', 'Game not initialized');\r\n      return;\r\n    }\r\n    \r\n    // Check if game already started\r\n    if (this.game.phase !== GamePhase.Setup) {\r\n      if (this.observerModeEnabled) {\r\n        this.handleObserverJoin(msg, peerId);\r\n      } else {\r\n        this.sendError(peerId, 'GAME_ALREADY_STARTED', 'Game in progress');\r\n        this.emit('late-joiner-rejected', peerId, msg.playerName);\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Find first available player slot (not yet connected)\r\n    const availablePlayer = this.game.players.find(p => !this.playerConnections.has(p.id));\r\n    if (!availablePlayer) {\r\n      this.sendError(peerId, 'ROOM_FULL', 'All player slots are taken');\r\n      return;\r\n    }\r\n    \r\n    console.log('[Room] Assigning peer', peerId, 'to player slot:', availablePlayer.id);\r\n    \r\n    // Update player name if provided\r\n    if (msg.playerName && msg.playerName !== availablePlayer.name) {\r\n      availablePlayer.name = msg.playerName;\r\n      console.log('[Room] Updated player name to:', msg.playerName);\r\n    }\r\n    \r\n    // Accept connection\r\n    const playerInfo: ConnectedPlayer = {\r\n      playerId: availablePlayer.id,  // Use the game's player ID\r\n      playerName: availablePlayer.name,\r\n      peerId: peerId,\r\n      connected: true,\r\n      connectedAt: Date.now()\r\n    };\r\n    \r\n    this.playerConnections.set(msg.playerId, playerInfo);\r\n    \r\n    this.emit('peer-connected', playerInfo);\r\n    \r\n    // Check if all players connected - if so, start the game\r\n    if (this.game.phase === GamePhase.Setup && this.playerConnections.size === this.game.players.length) {\r\n      this.game.phase = GamePhase.Playing;\r\n      console.log('[Room] All players connected - game starting!');\r\n      this.emit('game-state-updated', this.game);\r\n    }\r\n    \r\n    // Send current game state\r\n    this.sendGameState(peerId, 'INITIAL_SYNC');\r\n    \r\n    // Broadcast player joined to others\r\n    this.broadcastPlayerStatus(msg.playerId, 'connected');\r\n  }\r\n  \r\n  /**\r\n   * Handle observer join (read-only).\r\n   */\r\n  private handleObserverJoin(msg: JoinGameMessage, peerId: string): void {\r\n    this.observers.add(peerId);\r\n    \r\n    // Send current state (read-only)\r\n    this.sendGameState(peerId, 'OBSERVER_JOIN');\r\n    \r\n    // Send observer notification\r\n    const observerMsg = {\r\n      type: 'OBSERVER_MODE',\r\n      messageId: `obs_${Date.now()}`,\r\n      gameId: this.game!.id,\r\n      senderId: this.hostPeerId,\r\n      turnNumber: this.game!.turnNumber,\r\n      timestamp: Date.now(),\r\n      message: 'Joined as observer (read-only)'\r\n    };\r\n    \r\n    this.sendToPeer(peerId, observerMsg);\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // ACTION PROCESSING (GAME ENGINE INTEGRATION)\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle ACTION_REQUEST from peer.\r\n   * Validates via engine and applies if valid.\r\n   */\r\n  private handleActionRequest(msg: ActionRequestMessage, peerId: string): void {\r\n    if (!this.game) {\r\n      this.sendActionResult(peerId, msg.messageId, false, 'Game not found');\r\n      return;\r\n    }\r\n    \r\n    // Race condition protection: Only process one action at a time\r\n    if (this.isProcessingAction) {\r\n      this.sendActionResult(peerId, msg.messageId, false, 'Host is processing another action. Please wait.');\r\n      return;\r\n    }\r\n    \r\n    this.isProcessingAction = true;\r\n    \r\n    // Process action via engine (NO GAME LOGIC HERE)\r\n    const result = this.processAction(msg.action);\r\n    \r\n    // Send result to requester\r\n    this.sendActionResult(\r\n      peerId,\r\n      msg.messageId,\r\n      result.valid,\r\n      result.error\r\n    );\r\n    \r\n    // Release lock\r\n    this.isProcessingAction = false;\r\n    \r\n    // Emit event\r\n    this.emit('action-processed', msg.action, result.valid);\r\n  }\r\n  \r\n  /**\r\n   * Process action via game engine.\r\n   * ALL VALIDATION AND LOGIC IN ENGINE - NOT HERE.\r\n   */\r\n  private processAction(action: GameAction): {\r\n    valid: boolean;\r\n    error?: string;\r\n    code?: string;\r\n  } {\r\n    if (!this.game) {\r\n      this.isProcessingAction = false; // Release lock on early return\r\n      return { valid: false, error: 'Game not initialized' };\r\n    }\r\n    \r\n    // Step 1: Validate via engine\r\n    const validation = validateAction(this.game, action);\r\n    if (!validation.valid) {\r\n      this.isProcessingAction = false; // Release lock on validation failure\r\n      return {\r\n        valid: false,\r\n        error: validation.error,\r\n        code: validation.code\r\n      };\r\n    }\r\n    \r\n    // Step 2: Apply via engine\r\n    let newGame = applyAction(this.game, action);\r\n    \r\n    // Step 3: Advance turn via engine\r\n    const turnResult = advanceTurn(newGame);\r\n    newGame = turnResult.game;\r\n    \r\n    // Step 4: Check endgame via engine\r\n    if (turnResult.gameFinished) {\r\n      newGame = finalizeGame(newGame);\r\n    }\r\n    \r\n    // Step 5: Update authoritative state\r\n    this.game = newGame;\r\n    if (this.syncHandler) {\r\n      this.syncHandler.updateGame(newGame);\r\n    }\r\n    \r\n    // Step 6: Broadcast new state to all peers\r\n    this.broadcastGameState(newGame, action);\r\n    \r\n    // Step 7: Emit to local UI\r\n    this.emit('game-state-updated', newGame);\r\n    \r\n    return { valid: true };\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // STATE BROADCASTING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Broadcast game state to all connected peers.\r\n   */\r\n  private broadcastGameState(game: Game, lastAction?: GameAction): void {\r\n    const stateHash = calculateStateHash(game);\r\n    \r\n    const stateMsg: GameStateMessage = {\r\n      type: P2PMessageType.GameState,\r\n      messageId: `state_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      gameId: game.id,\r\n      senderId: this.hostPeerId,\r\n      turnNumber: game.turnNumber,\r\n      timestamp: Date.now(),\r\n      game: game,\r\n      reason: 'ACTION_APPLIED' as any,\r\n      lastAction: lastAction,\r\n      stateHash: stateHash\r\n    };\r\n    \r\n    console.log('[Room] Broadcasting state to', this.connectedPeers.size, 'peers');\r\n    \r\n    // Send to all connected peers (including observers)\r\n    this.connectedPeers.forEach((conn, peerId) => {\r\n      try {\r\n        conn.send(stateMsg);\r\n      } catch (err) {\r\n        console.error('[Room] Failed to send to', peerId, err);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Send game state to specific peer.\r\n   */\r\n  private sendGameState(peerId: string, reason: string): void {\r\n    if (!this.game) return;\r\n    \r\n    const stateHash = calculateStateHash(this.game);\r\n    \r\n    const stateMsg: GameStateMessage = {\r\n      type: P2PMessageType.GameState,\r\n      messageId: `state_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      gameId: this.game.id,\r\n      senderId: this.hostPeerId,\r\n      turnNumber: this.game.turnNumber,\r\n      timestamp: Date.now(),\r\n      game: this.game,\r\n      reason: reason as any,\r\n      stateHash: stateHash\r\n    };\r\n    \r\n    this.sendToPeer(peerId, stateMsg);\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // DISCONNECT HANDLING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle peer disconnect.\r\n   */\r\n  private handlePeerDisconnect(peerId: string): void {\r\n    // Remove from connected peers\r\n    this.connectedPeers.delete(peerId);\r\n    \r\n    // Check if it's a player\r\n    let disconnectedPlayer: ConnectedPlayer | undefined;\r\n    \r\n    this.playerConnections.forEach((player) => {\r\n      if (player.peerId === peerId && player.connected) {\r\n        player.connected = false;\r\n        player.disconnectTime = Date.now();\r\n        disconnectedPlayer = player;\r\n      }\r\n    });\r\n    \r\n    if (disconnectedPlayer) {\r\n      this.emit('peer-disconnected', peerId, disconnectedPlayer.playerName);\r\n      \r\n      // Check if it's their turn\r\n      if (this.game) {\r\n        const currentPlayer = this.game.players[this.game.currentPlayerIndex];\r\n        if (currentPlayer.id === disconnectedPlayer.playerId) {\r\n          this.handleCurrentPlayerDisconnect(disconnectedPlayer);\r\n        }\r\n      }\r\n      \r\n      // Broadcast to others\r\n      this.broadcastPlayerStatus(disconnectedPlayer.playerId, 'disconnected');\r\n    } else if (this.observers.has(peerId)) {\r\n      // Observer disconnected\r\n      this.observers.delete(peerId);\r\n      console.log('[Room] Observer disconnected:', peerId);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle current player disconnect - start auto-skip timer.\r\n   */\r\n  private handleCurrentPlayerDisconnect(player: ConnectedPlayer): void {\r\n    console.log('[Room] Current player disconnected, starting grace period');\r\n    \r\n    // Start grace period timer\r\n    const timer = setTimeout(() => {\r\n      // Check if still disconnected\r\n      if (!player.connected) {\r\n        console.log('[Room] Grace period expired, auto-skipping turn');\r\n        this.autoSkipTurn(player.playerId);\r\n      }\r\n      this.autoSkipTimers.delete(player.playerId);\r\n    }, this.PEER_RECONNECT_GRACE_PERIOD);\r\n    \r\n    this.autoSkipTimers.set(player.playerId, timer);\r\n  }\r\n  \r\n  /**\r\n   * Auto-skip turn for disconnected player.\r\n   */\r\n  private autoSkipTurn(playerId: string): void {\r\n    if (!this.game) return;\r\n    \r\n    // Verify still their turn\r\n    const currentPlayer = this.game.players[this.game.currentPlayerIndex];\r\n    if (currentPlayer.id !== playerId) {\r\n      return; // Not their turn anymore\r\n    }\r\n    \r\n    const player = this.playerConnections.get(playerId);\r\n    if (!player) return;\r\n    \r\n    console.log('[Room] Auto-skipping turn for:', player.playerName);\r\n    \r\n    // Create REST action\r\n    const restAction: GameAction = {\r\n      type: 'REST' as any,\r\n      playerId: playerId,\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    // Process via engine\r\n    const result = this.processAction(restAction);\r\n    \r\n    if (result.valid) {\r\n      this.emit('turn-auto-skipped', playerId, player.playerName);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle player reconnect.\r\n   */\r\n  private handlePlayerReconnect(msg: JoinGameMessage, peerId: string): void {\r\n    const player = this.playerConnections.get(msg.playerId);\r\n    if (!player) return;\r\n    \r\n    console.log('[Room] Player reconnecting:', player.playerName);\r\n    \r\n    // Cancel auto-skip timer if pending\r\n    const timer = this.autoSkipTimers.get(msg.playerId);\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      this.autoSkipTimers.delete(msg.playerId);\r\n      console.log('[Room] Cancelled auto-skip timer');\r\n    }\r\n    \r\n    // Update connection info\r\n    player.peerId = peerId;\r\n    player.connected = true;\r\n    player.disconnectTime = undefined;\r\n    \r\n    // Send full state resync\r\n    this.sendGameState(peerId, 'RECONNECT');\r\n    \r\n    this.emit('peer-reconnected', peerId, player.playerName);\r\n    \r\n    // Broadcast to others\r\n    this.broadcastPlayerStatus(msg.playerId, 'connected');\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // RESYNC HANDLING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle resync request from peer.\r\n   */\r\n  private handleResyncRequest(request: ResyncRequestMessage, peerId: string): void {\r\n    if (!this.syncHandler || !this.game) return;\r\n    \r\n    console.log('[Room] Resync request from:', peerId, 'reason:', request.reason);\r\n    \r\n    // Use sync handler to create response\r\n    const response = this.syncHandler.handleResyncRequest(request, peerId);\r\n    \r\n    if (response) {\r\n      this.sendToPeer(peerId, response);\r\n    } else {\r\n      console.warn('[Room] Resync rejected (rate limited)');\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // MESSAGING HELPERS\r\n  // ==========================================================================\r\n  \r\n  private sendToPeer(peerId: string, message: any): void {\r\n    const conn = this.connectedPeers.get(peerId);\r\n    if (conn) {\r\n      try {\r\n        conn.send(message);\r\n      } catch (err) {\r\n        console.error('[Room] Failed to send to', peerId, err);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private sendActionResult(\r\n    peerId: string,\r\n    requestMessageId: string,\r\n    success: boolean,\r\n    errorMessage?: string\r\n  ): void {\r\n    const result = P2PMessageFactory.createActionResult(\r\n      this.game!.id,\r\n      this.hostPeerId,\r\n      this.game!.turnNumber,\r\n      requestMessageId,\r\n      success,\r\n      success ? this.game!.turnNumber : undefined,\r\n      errorMessage\r\n    );\r\n    \r\n    this.sendToPeer(peerId, result);\r\n  }\r\n  \r\n  private sendError(peerId: string, code: string, message: string): void {\r\n    const errorMsg = P2PMessageFactory.createError(\r\n      this.game?.id || '',\r\n      this.hostPeerId,\r\n      this.game?.turnNumber || 0,\r\n      'ERROR' as any,\r\n      code as any,\r\n      message,\r\n      true\r\n    );\r\n    \r\n    this.sendToPeer(peerId, errorMsg);\r\n    \r\n    // Disconnect after error\r\n    setTimeout(() => {\r\n      const conn = this.connectedPeers.get(peerId);\r\n      if (conn) {\r\n        conn.close();\r\n      }\r\n    }, 1000);\r\n  }\r\n  \r\n  private broadcastPlayerStatus(playerId: string, status: 'connected' | 'disconnected'): void {\r\n    const statusMsg = {\r\n      type: 'PLAYER_STATUS',\r\n      messageId: `status_${Date.now()}`,\r\n      gameId: this.game?.id,\r\n      senderId: this.hostPeerId,\r\n      turnNumber: this.game?.turnNumber || 0,\r\n      timestamp: Date.now(),\r\n      playerId,\r\n      status\r\n    };\r\n    \r\n    this.connectedPeers.forEach((conn, peerId) => {\r\n      // Don't send to observers\r\n      if (!this.observers.has(peerId)) {\r\n        this.sendToPeer(peerId, statusMsg);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Get room code to share with other players.\r\n   */\r\n  getRoomCode(): string {\r\n    return this.roomCode;\r\n  }\r\n  \r\n  /**\r\n   * Get host peer ID (for direct connection).\r\n   */\r\n  getHostPeerId(): string {\r\n    return this.hostPeerId;\r\n  }\r\n  \r\n  /**\r\n   * Get current game state (read-only).\r\n   */\r\n  getGame(): Game | null {\r\n    return this.game;\r\n  }\r\n  \r\n  /**\r\n   * Get room info.\r\n   */\r\n  getRoomInfo(): RoomInfo | null {\r\n    if (!this.game) return null;\r\n    \r\n    return {\r\n      roomCode: this.roomCode,\r\n      gameId: this.game.id,\r\n      hostPeerId: this.hostPeerId,\r\n      createdAt: this.config ? Date.now() : 0,\r\n      playerCount: this.game.players.length,\r\n      connectedPlayers: this.getConnectedPlayerCount(),\r\n      gamePhase: this.game.phase\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get list of connected players.\r\n   */\r\n  getConnectedPlayers(): ConnectedPlayer[] {\r\n    return Array.from(this.playerConnections.values());\r\n  }\r\n  \r\n  private getConnectedPlayerCount(): number {\r\n    let count = 1; // Host always counts\r\n    this.playerConnections.forEach(p => {\r\n      if (p.connected) count++;\r\n    });\r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Close the room and disconnect all peers.\r\n   */\r\n  close(): void {\r\n    console.log('[Room] Closing room');\r\n    \r\n    // Clear timers\r\n    this.autoSkipTimers.forEach(timer => clearTimeout(timer));\r\n    this.autoSkipTimers.clear();\r\n    \r\n    // Disconnect all peers\r\n    this.connectedPeers.forEach((conn, peerId) => {\r\n      try {\r\n        const endMsg = {\r\n          type: 'GAME_ENDED',\r\n          messageId: `end_${Date.now()}`,\r\n          gameId: this.game?.id,\r\n          senderId: this.hostPeerId,\r\n          turnNumber: this.game?.turnNumber || 0,\r\n          timestamp: Date.now(),\r\n          reason: 'Host closed room'\r\n        };\r\n        conn.send(endMsg);\r\n        conn.close();\r\n      } catch (err) {\r\n        console.error('[Room] Error closing connection:', err);\r\n      }\r\n    });\r\n    \r\n    // Destroy peer\r\n    if (this.peer) {\r\n      this.peer.destroy();\r\n      this.peer = null;\r\n    }\r\n    \r\n    // Clear state\r\n    this.connectedPeers.clear();\r\n    this.playerConnections.clear();\r\n    this.observers.clear();\r\n    \r\n    console.log('[Room] Closed');\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // EVENT SYSTEM\r\n  // ==========================================================================\r\n  \r\n  on<K extends keyof RoomEventMap>(event: K, listener: RoomEventMap[K]): void {\r\n    if (!this.eventListeners.has(event)) {\r\n      this.eventListeners.set(event, new Set());\r\n    }\r\n    this.eventListeners.get(event)!.add(listener as Function);\r\n  }\r\n  \r\n  off<K extends keyof RoomEventMap>(event: K, listener: RoomEventMap[K]): void {\r\n    const listeners = this.eventListeners.get(event);\r\n    if (listeners) {\r\n      listeners.delete(listener as Function);\r\n    }\r\n  }\r\n  \r\n  private emit<K extends keyof RoomEventMap>(\r\n    event: K,\r\n    ...args: Parameters<RoomEventMap[K]>\r\n  ): void {\r\n    const listeners = this.eventListeners.get(event);\r\n    if (listeners) {\r\n      listeners.forEach(listener => {\r\n        try {\r\n          listener(...args);\r\n        } catch (err) {\r\n          console.error('[Room] Event listener error:', err);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// USAGE EXAMPLE\r\n// ============================================================================\r\n\r\n/*\r\n\r\n// HTML\r\n<div id=\"host-screen\">\r\n  <h1>Create Game</h1>\r\n  <input id=\"player1\" placeholder=\"Player 1 name\" value=\"Alice\" />\r\n  <input id=\"player2\" placeholder=\"Player 2 name\" value=\"Bob\" />\r\n  <input id=\"player3\" placeholder=\"Player 3 name\" value=\"Charlie\" />\r\n  <button id=\"create-btn\">Create Room</button>\r\n  \r\n  <div id=\"room-info\" style=\"display:none;\">\r\n    <h2>Room Created!</h2>\r\n    <div class=\"room-code\">\r\n      <h3>Share this code:</h3>\r\n      <div id=\"code-display\"></div>\r\n    </div>\r\n    <div id=\"players-list\"></div>\r\n    <button id=\"start-game-btn\">Start Game</button>\r\n  </div>\r\n</div>\r\n\r\n// TypeScript/JavaScript\r\nimport { P2PGameRoom } from './p2p/browserRoom';\r\n\r\nlet room: P2PGameRoom;\r\n\r\ndocument.getElementById('create-btn')?.addEventListener('click', async () => {\r\n  const player1 = (document.getElementById('player1') as HTMLInputElement).value;\r\n  const player2 = (document.getElementById('player2') as HTMLInputElement).value;\r\n  const player3 = (document.getElementById('player3') as HTMLInputElement).value;\r\n  \r\n  const playerNames = [player1, player2, player3].filter(n => n.trim());\r\n  \r\n  if (playerNames.length < 2) {\r\n    alert('Need at least 2 players');\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    // Create room (browser becomes host)\r\n    room = new P2PGameRoom();\r\n    \r\n    // Listen to events\r\n    room.on('room-created', (info) => {\r\n      console.log('Room created:', info);\r\n      displayRoomCode(info.roomCode);\r\n      showWaitingForPlayers();\r\n    });\r\n    \r\n    room.on('peer-connected', (player) => {\r\n      console.log('Player joined:', player.playerName);\r\n      addPlayerToList(player);\r\n    });\r\n    \r\n    room.on('peer-disconnected', (peerId, playerName) => {\r\n      console.log('Player left:', playerName);\r\n      removePlayerFromList(playerName);\r\n    });\r\n    \r\n    room.on('action-processed', (action, success) => {\r\n      if (success) {\r\n        console.log('Action applied:', action.type);\r\n        updateGameUI(room.getGame());\r\n      }\r\n    });\r\n    \r\n    // Create room\r\n    const roomInfo = await room.createRoom(playerNames, undefined, true);\r\n    \r\n  } catch (error) {\r\n    alert('Failed to create room: ' + error.message);\r\n  }\r\n});\r\n\r\nfunction displayRoomCode(code: string) {\r\n  const codeDisplay = document.getElementById('code-display');\r\n  if (codeDisplay) {\r\n    codeDisplay.textContent = code;\r\n    codeDisplay.style.fontSize = '48px';\r\n    codeDisplay.style.fontWeight = 'bold';\r\n    codeDisplay.style.letterSpacing = '8px';\r\n  }\r\n  \r\n  document.getElementById('room-info')!.style.display = 'block';\r\n}\r\n\r\nfunction showWaitingForPlayers() {\r\n  const playersList = document.getElementById('players-list');\r\n  if (playersList) {\r\n    playersList.innerHTML = '<p>Waiting for players to join...</p>';\r\n  }\r\n}\r\n\r\nfunction addPlayerToList(player: ConnectedPlayer) {\r\n  const playersList = document.getElementById('players-list');\r\n  if (playersList) {\r\n    const div = document.createElement('div');\r\n    div.id = `player-${player.playerId}`;\r\n    div.textContent = `✓ ${player.playerName} (connected)`;\r\n    playersList.appendChild(div);\r\n  }\r\n}\r\n\r\nfunction removePlayerFromList(playerName: string) {\r\n  // Find and update player in list\r\n  const playersList = document.getElementById('players-list');\r\n  if (playersList) {\r\n    Array.from(playersList.children).forEach(child => {\r\n      if (child.textContent?.includes(playerName)) {\r\n        child.textContent = `✗ ${playerName} (disconnected)`;\r\n        (child as HTMLElement).style.color = '#999';\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction updateGameUI(game: Game | null) {\r\n  if (!game) return;\r\n  \r\n  // Update your game UI with new state\r\n  console.log('Current turn:', game.turnNumber);\r\n  console.log('Current player:', game.players[game.currentPlayerIndex].name);\r\n}\r\n\r\n*/\r\n\r\nexport default P2PGameRoom;\r\n","/**\r\n * Browser-Only P2P Client (Join Room)\r\n * \r\n * Pure client-side implementation for joining a P2P game room.\r\n * Client connects to host peer and receives game state updates.\r\n * \r\n * Features:\r\n * - Join room by entering code\r\n * - Connect to host via PeerJS\r\n * - Receive game state from host (read-only)\r\n * - Send action requests to host\r\n * - Auto-reconnect on disconnect\r\n * \r\n * Usage:\r\n *   const client = new P2PGameClient();\r\n *   await client.joinRoom('A3F9K2', 'player_1', 'Alice');\r\n *   \r\n *   // Send action\r\n *   await client.sendAction({\r\n *     type: ActionType.PlayMerchantCard,\r\n *     playerId: 'player_1',\r\n *     cardId: 'card123',\r\n *     timestamp: Date.now()\r\n *   });\r\n */\r\n\r\n// @ts-ignore - PeerJS types installed separately\r\nimport Peer, { DataConnection } from 'peerjs';\r\nimport { Game, GameAction, GamePhase } from '../types/domain';\r\nimport {\r\n  ClientStateSyncHandler,\r\n  calculateStateHash\r\n} from './stateSync';\r\nimport {\r\n  P2PMessage,\r\n  P2PMessageType,\r\n  JoinGameMessage,\r\n  GameStateMessage,\r\n  ActionRequestMessage,\r\n  ActionResultMessage,\r\n  ErrorMessage,\r\n  P2PMessageFactory\r\n} from './protocol';\r\nimport { MessageDeduplicator } from './stateSync';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface JoinRoomConfig {\r\n  roomCode: string;\r\n  playerId: string;\r\n  playerName: string;\r\n  timeout?: number; // Connection timeout in ms (default: 30000)\r\n}\r\n\r\nexport interface ClientRoomInfo {\r\n  roomCode: string;\r\n  gameId: string;\r\n  hostPeerId: string;\r\n  playerId: string;\r\n  playerName: string;\r\n  connected: boolean;\r\n  connectedAt?: number;\r\n}\r\n\r\nexport type ClientEventMap = {\r\n  'connected': (info: ClientRoomInfo) => void;\r\n  'disconnected': (reason: string) => void;\r\n  'reconnecting': () => void;\r\n  'reconnected': () => void;\r\n  'game-state-received': (game: Game) => void;\r\n  'action-accepted': (action: GameAction) => void;\r\n  'action-rejected': (action: GameAction, error: string) => void;\r\n  'error': (error: Error) => void;\r\n  'host-disconnected': () => void;\r\n  'resync-complete': (game: Game) => void;\r\n  'player-status-changed': (playerId: string, status: 'connected' | 'disconnected') => void;\r\n};\r\n\r\n// ============================================================================\r\n// BROWSER P2P CLIENT\r\n// ============================================================================\r\n\r\n/**\r\n * P2P Game Client - Browser-only join implementation.\r\n * \r\n * This class manages:\r\n * - Connecting to host by room code\r\n * - Receiving game state updates\r\n * - Sending action requests\r\n * - Auto-reconnection\r\n * - State consistency validation\r\n * \r\n * NO SERVER REQUIRED - runs entirely in the browser.\r\n */\r\nexport class P2PGameClient {\r\n  // PeerJS\r\n  private peer: Peer | null = null;\r\n  private hostConnection: DataConnection | null = null;\r\n  private clientPeerId: string = '';\r\n  \r\n  // Connection info\r\n  private roomCode: string = '';\r\n  private hostPeerId: string = '';\r\n  private playerId: string = '';\r\n  private playerName: string = '';\r\n  \r\n  // Game state (READ-ONLY - received from host)\r\n  private game: Game | null = null;\r\n  private syncHandler: ClientStateSyncHandler | null = null;\r\n  \r\n  // Connection management\r\n  private connected: boolean = false;\r\n  private connecting: boolean = false;\r\n  private reconnectAttempts: number = 0;\r\n  private readonly MAX_RECONNECT_ATTEMPTS = 5;\r\n  private reconnectTimer: NodeJS.Timeout | null = null;\r\n  private readonly RECONNECT_DELAY = 3000; // 3 seconds\r\n  \r\n  // Host disconnect detection\r\n  private hostAliveTimer: ReturnType<typeof setInterval> | null = null;\r\n  private lastHostMessage: number = 0;\r\n  private readonly HOST_TIMEOUT = 30000; // 30 seconds\r\n  \r\n  // Safeguards\r\n  private deduplicator: MessageDeduplicator;\r\n  \r\n  // Pending actions\r\n  private pendingActions: Map<string, {\r\n    action: GameAction;\r\n    resolve: (success: boolean) => void;\r\n    reject: (error: Error) => void;\r\n    timestamp: number;\r\n  }> = new Map();\r\n  private readonly ACTION_TIMEOUT = 10000; // 10 seconds\r\n  \r\n  // Events\r\n  private eventListeners: Map<keyof ClientEventMap, Set<Function>> = new Map();\r\n  \r\n  constructor() {\r\n    this.deduplicator = new MessageDeduplicator();\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // JOIN ROOM\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Join a game room by room code.\r\n   * \r\n   * @param roomCode - 6-character room code from host\r\n   * @param playerId - Player ID (must match server's player list)\r\n   * @param playerName - Player name for display\r\n   * @param timeout - Connection timeout in ms (default: 30000)\r\n   * @returns Promise<ClientRoomInfo> - Connection details\r\n   */\r\n  async joinRoom(\r\n    roomCode: string,\r\n    playerId: string,\r\n    playerName: string,\r\n    timeout: number = 60000\r\n  ): Promise<ClientRoomInfo> {\r\n    if (this.connected || this.connecting) {\r\n      throw new Error('Already connected or connecting to a room');\r\n    }\r\n    \r\n    if (this.peer) {\r\n      throw new Error('Peer already exists. Call disconnect() first.');\r\n    }\r\n    \r\n    this.connecting = true;\r\n    this.roomCode = roomCode.toUpperCase();\r\n    this.playerId = playerId;\r\n    this.playerName = playerName;\r\n    \r\n    try {\r\n      // Step 1: Initialize PeerJS client\r\n      this.clientPeerId = `client_${playerId}_${Date.now()}`;\r\n      await this.initializePeerClient();\r\n      \r\n      // Step 2: Derive host peer ID from room code\r\n      // Host uses format: host_{roomCode}_{timestamp}\r\n      // We need to discover the exact host peer ID\r\n      this.hostPeerId = await this.discoverHostPeerId(roomCode, timeout);\r\n      \r\n      // Step 3: Connect to host\r\n      await this.connectToHost(timeout);\r\n      \r\n      // Step 4: Send JOIN_GAME message\r\n      await this.sendJoinRequest();\r\n      \r\n      // Step 5: Wait for initial game state\r\n      await this.waitForInitialState(timeout);\r\n      \r\n      // Step 6: Start host alive monitoring\r\n      this.startHostMonitoring();\r\n      \r\n      this.connected = true;\r\n      this.connecting = false;\r\n      this.reconnectAttempts = 0;\r\n      \r\n      const info: ClientRoomInfo = {\r\n        roomCode: this.roomCode,\r\n        gameId: this.game!.id,\r\n        hostPeerId: this.hostPeerId,\r\n        playerId: this.playerId,\r\n        playerName: this.playerName,\r\n        connected: true,\r\n        connectedAt: Date.now()\r\n      };\r\n      \r\n      console.log('[Client] Successfully joined room:', info);\r\n      this.emit('connected', info);\r\n      \r\n      return info;\r\n      \r\n    } catch (error) {\r\n      this.connecting = false;\r\n      console.error('[Client] Failed to join room:', error);\r\n      this.emit('error', error as Error);\r\n      this.cleanup();\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Initialize PeerJS as client.\r\n   */\r\n  private async initializePeerClient(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      // Set a timeout for initialization\r\n      const timeout = setTimeout(() => {\r\n        if (this.peer) {\r\n          this.peer.destroy();\r\n        }\r\n        reject(new Error('PeerJS initialization timeout (10s). Please check your internet connection and try again.'));\r\n      }, 10000);\r\n      \r\n      // Create peer - use async-games working configuration\r\n      try {\r\n        console.log('[Client] Creating Peer:', this.clientPeerId);\r\n        this.peer = new Peer(this.clientPeerId, {\r\n          host: '0.peerjs.com',\r\n          port: 443,\r\n          path: '/',\r\n          secure: true,\r\n          debug: 1,\r\n          config: {\r\n            iceServers: [\r\n              { urls: 'stun:stun.l.google.com:19302' },\r\n              { urls: 'stun:global.stun.twilio.com:3478' },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:80',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:443',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              },\r\n              {\r\n                urls: 'turn:openrelay.metered.ca:443?transport=tcp',\r\n                username: 'openrelayproject',\r\n                credential: 'openrelayproject'\r\n              }\r\n            ]\r\n          }\r\n        });\r\n        console.log('[Client] Peer instance created, waiting for signaling server...');\r\n      } catch (err) {\r\n        clearTimeout(timeout);\r\n        reject(new Error(`Failed to create Peer: ${err}`));\r\n        return;\r\n      }\r\n      \r\n      this.peer.on('open', (id: string) => {\r\n        clearTimeout(timeout);\r\n        console.log('[Client] ✓ Peer opened, ID:', id);\r\n        console.log('[Client] ✓ Connected to signaling server');\r\n        resolve();\r\n      });\r\n      \r\n      this.peer.on('error', (err: any) => {\r\n        clearTimeout(timeout);\r\n        console.error('[Client] ✗ PeerJS error:', err);\r\n        const errorMsg = err.type ? `${err.type}: ${err.message || err}` : String(err);\r\n        reject(new Error(`Signaling server error: ${errorMsg}. Try refreshing the page.`));\r\n      });\r\n      \r\n      this.peer.on('disconnected', () => {\r\n        console.warn('[Client] PeerJS disconnected from signaling server');\r\n        this.peer?.reconnect();\r\n      });\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Discover host peer ID from room code.\r\n   * \r\n   * Strategy: Try to connect to common host ID patterns.\r\n   * Host format: host_{roomCode}_{timestamp}\r\n   * \r\n   * For production: Use a discovery service or QR code with full peer ID.\r\n   */\r\n  private async discoverHostPeerId(\r\n    roomCode: string,\r\n    timeout: number\r\n  ): Promise<string> {\r\n    // For this implementation, we'll require the full host peer ID to be shared\r\n    // along with the room code. In a real app, you could:\r\n    // 1. Use a lightweight discovery service\r\n    // 2. Encode full peer ID in QR code\r\n    // 3. Use a peer discovery protocol\r\n    \r\n    // Check localStorage for cached host peer ID\r\n    const cached = this.getCachedHostPeerId(roomCode);\r\n    if (cached) {\r\n      console.log('[Client] Using cached host peer ID:', cached);\r\n      return cached;\r\n    }\r\n    \r\n    throw new Error(\r\n      'Host peer ID not found. Please provide the full peer ID along with room code. ' +\r\n      'Host should share both: Room Code + Host Peer ID'\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Get cached host peer ID from localStorage.\r\n   */\r\n  private getCachedHostPeerId(roomCode: string): string | null {\r\n    try {\r\n      if (typeof localStorage === 'undefined') return null;\r\n      \r\n      const cached = localStorage.getItem(`host_peer_${roomCode}`);\r\n      if (cached) {\r\n        const data = JSON.parse(cached);\r\n        // Cache expires after 1 hour\r\n        if (Date.now() - data.timestamp < 3600000) {\r\n          return data.peerId;\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.warn('[Client] Failed to read cache:', err);\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Connect to host peer.\r\n   */\r\n  private async connectToHost(timeout: number): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      console.log('[Client] >>> Attempting connection to host:', this.hostPeerId);\r\n      \r\n      const timeoutTimer = setTimeout(() => {\r\n        console.error('[Client] ✗ Connection timeout after', timeout, 'ms');\r\n        this.hostConnection?.close();\r\n        reject(new Error('Connection timeout. Make sure you and the host are on the same network (WiFi). Check that the Host Peer ID is correct.'));\r\n      }, timeout);\r\n      \r\n      console.log('[Client] Creating DataConnection...');\r\n      this.hostConnection = this.peer!.connect(this.hostPeerId, {\r\n        reliable: true,\r\n        serialization: 'json'\r\n      });\r\n      \r\n      // CRITICAL: Attach ALL handlers IMMEDIATELY after creating connection\r\n      this.hostConnection.on('open', () => {\r\n        clearTimeout(timeoutTimer);\r\n        console.log('[Client] ✓ Connection opened to host');\r\n        this.setupConnectionListeners();\r\n        resolve();\r\n      });\r\n      \r\n      this.hostConnection.on('error', (err: Error) => {\r\n        clearTimeout(timeoutTimer);\r\n        console.error('[Client] ✗ Connection error:', err);\r\n        reject(new Error(`Connection failed: ${err.message}. Ensure you're on the same network as the host.`));\r\n      });\r\n      \r\n      this.hostConnection.on('close', () => {\r\n        console.log('[Client] Connection closed during setup');\r\n      });\r\n      \r\n      console.log('[Client] Connection handlers attached, waiting for open...');\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Set up listeners for host connection.\r\n   */\r\n  private setupConnectionListeners(): void {\r\n    if (!this.hostConnection) return;\r\n    \r\n    console.log('[Client] Setting up data/close handlers...');\r\n    \r\n    this.hostConnection.on('data', (data: any) => {\r\n      this.lastHostMessage = Date.now();\r\n      console.log('[Client] <<< Received message type:', (data as P2PMessage).type);\r\n      this.handleHostMessage(data as P2PMessage);\r\n    });\r\n    \r\n    this.hostConnection.on('close', () => {\r\n      console.log('[Client] ✗ Host connection closed');\r\n      this.handleHostDisconnect();\r\n    });\r\n    \r\n    this.hostConnection.on('error', (err: Error) => {\r\n      console.error('[Client] ✗ Host connection error:', err);\r\n    });\r\n    \r\n    console.log('[Client] ✓ All connection listeners ready');\r\n  }\r\n  \r\n  /**\r\n   * Send JOIN_GAME request to host.\r\n   */\r\n  private async sendJoinRequest(): Promise<void> {\r\n    const joinMsg: JoinGameMessage = P2PMessageFactory.createJoinGame(\r\n      '', // gameId not known yet\r\n      this.clientPeerId,\r\n      this.playerId,\r\n      this.playerName,\r\n      '1.0.0', // clientVersion\r\n      undefined // lastKnownTurn\r\n    );\r\n    \r\n    this.sendToHost(joinMsg);\r\n    console.log('[Client] Sent JOIN_GAME request');\r\n  }\r\n  \r\n  /**\r\n   * Wait for initial game state from host.\r\n   */\r\n  private async waitForInitialState(timeout: number): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const timeoutTimer = setTimeout(() => {\r\n        reject(new Error('Timeout waiting for initial game state'));\r\n      }, timeout);\r\n      \r\n      const handler = (game: Game) => {\r\n        clearTimeout(timeoutTimer);\r\n        this.off('game-state-received', handler);\r\n        resolve();\r\n      };\r\n      \r\n      this.on('game-state-received', handler);\r\n    });\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // MESSAGE HANDLING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle incoming messages from host.\r\n   */\r\n  private handleHostMessage(message: P2PMessage): void {\r\n    // Idempotency check (Layer 1)\r\n    if (!this.deduplicator.shouldProcess(message)) {\r\n      console.log('[Client] Ignoring duplicate message:', message.messageId);\r\n      return;\r\n    }\r\n    \r\n    console.log('[Client] Received message:', message.type);\r\n    \r\n    switch (message.type) {\r\n      case P2PMessageType.GameState:\r\n        this.handleGameState(message as GameStateMessage);\r\n        break;\r\n        \r\n      case P2PMessageType.ActionResult:\r\n        this.handleActionResult(message as ActionResultMessage);\r\n        break;\r\n        \r\n      case P2PMessageType.Error:\r\n        this.handleError(message as ErrorMessage);\r\n        break;\r\n        \r\n      default:\r\n        // Check for custom message types\r\n        if ((message as any).type === 'RESYNC_RESPONSE') {\r\n          this.handleResyncResponse(message as any);\r\n        } else if ((message as any).type === 'PLAYER_STATUS') {\r\n          this.handlePlayerStatus(message as any);\r\n        } else if ((message as any).type === 'GAME_ENDED') {\r\n          this.handleGameEnded(message as any);\r\n        } else {\r\n          console.warn('[Client] Unknown message type:', message.type);\r\n        }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle GAME_STATE message from host.\r\n   * This is the ONLY way client receives game state.\r\n   */\r\n  private handleGameState(message: GameStateMessage): void {\r\n    console.log('[Client] Received game state, turn:', message.turnNumber);\r\n    \r\n    // First state? Initialize sync handler\r\n    if (!this.syncHandler) {\r\n      this.syncHandler = new ClientStateSyncHandler(this.hostPeerId);\r\n      this.game = message.game;\r\n      console.log('[Client] Initial state received');\r\n      this.emit('game-state-received', message.game);\r\n      return;\r\n    }\r\n    \r\n    // Validate state via sync handler (Layers 2 & 3)\r\n    const result = this.syncHandler.handleGameState(message);\r\n    \r\n    if (result === 'applied') {\r\n      // State validated and applied\r\n      this.game = message.game;\r\n      console.log('[Client] State updated successfully');\r\n      this.emit('game-state-received', message.game);\r\n    } else if (result === 'resync_needed') {\r\n      // State hash mismatch or turn jump - request full resync\r\n      console.warn('[Client] State mismatch detected, requesting resync');\r\n      this.requestResync('STATE_MISMATCH');\r\n    } else {\r\n      // Ignored - stale message or duplicate\r\n      console.log('[Client] State message ignored (stale or duplicate)');\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle ACTION_RESULT from host.\r\n   */\r\n  private handleActionResult(message: ActionResultMessage): void {\r\n    console.log('[Client] Action result:', message.success ? 'accepted' : 'rejected');\r\n    \r\n    // Find pending action\r\n    const pending = this.pendingActions.get(message.requestMessageId);\r\n    if (!pending) {\r\n      console.warn('[Client] Received result for unknown action');\r\n      return;\r\n    }\r\n    \r\n    this.pendingActions.delete(message.requestMessageId);\r\n    \r\n    if (message.success) {\r\n      pending.resolve(true);\r\n      this.emit('action-accepted', pending.action);\r\n    } else {\r\n      pending.resolve(false);\r\n      this.emit('action-rejected', pending.action, message.errorMessage || 'Unknown error');\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle ERROR message from host.\r\n   */\r\n  private handleError(message: ErrorMessage): void {\r\n    console.error('[Client] Error from host:', message.errorCode, message.message);\r\n    \r\n    if (message.willDisconnect) {\r\n      this.emit('error', new Error(`Fatal error: ${message.message}`));\r\n      this.disconnect();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle RESYNC_RESPONSE from host.\r\n   */\r\n  private handleResyncResponse(message: any): void {\r\n    console.log('[Client] Resync response received');\r\n    \r\n    if (message.game) {\r\n      this.game = message.game;\r\n      this.emit('resync-complete', message.game);\r\n      this.emit('game-state-received', message.game);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle PLAYER_STATUS updates.\r\n   */\r\n  private handlePlayerStatus(message: any): void {\r\n    console.log('[Client] Player status update:', message.playerId, message.status);\r\n    this.emit('player-status-changed', message.playerId, message.status);\r\n  }\r\n  \r\n  /**\r\n   * Handle GAME_ENDED notification.\r\n   */\r\n  private handleGameEnded(message: any): void {\r\n    console.log('[Client] Game ended:', message.reason);\r\n    this.disconnect();\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // ACTION REQUESTS\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Send action request to host.\r\n   * \r\n   * CLIENT DOES NOT APPLY ACTION LOCALLY.\r\n   * Client waits for host to validate and broadcast new state.\r\n   * \r\n   * @param action - Action to request\r\n   * @returns Promise<boolean> - True if accepted, false if rejected\r\n   */\r\n  async sendAction(action: GameAction): Promise<boolean> {\r\n    if (!this.connected || !this.game) {\r\n      throw new Error('Not connected to room');\r\n    }\r\n    \r\n    // Validate it's this player's action\r\n    if (action.playerId !== this.playerId) {\r\n      throw new Error('Cannot send action for another player');\r\n    }\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const requestMsg: ActionRequestMessage = P2PMessageFactory.createActionRequest(\r\n        this.game!.id,\r\n        this.clientPeerId,\r\n        this.game!.turnNumber,\r\n        action\r\n      );\r\n      \r\n      // Store pending action\r\n      this.pendingActions.set(requestMsg.messageId, {\r\n        action,\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now()\r\n      });\r\n      \r\n      // Set timeout\r\n      setTimeout(() => {\r\n        if (this.pendingActions.has(requestMsg.messageId)) {\r\n          this.pendingActions.delete(requestMsg.messageId);\r\n          reject(new Error('Action request timeout'));\r\n        }\r\n      }, this.ACTION_TIMEOUT);\r\n      \r\n      // Send to host\r\n      this.sendToHost(requestMsg);\r\n      console.log('[Client] Sent action request:', action.type);\r\n    });\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // RESYNC\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Request full state resync from host.\r\n   */\r\n  private requestResync(reason: string): void {\r\n    if (!this.game) return;\r\n    \r\n    const resyncMsg = {\r\n      type: 'RESYNC_REQUEST',\r\n      messageId: `resync_${Date.now()}`,\r\n      gameId: this.game.id,\r\n      senderId: this.clientPeerId,\r\n      turnNumber: this.game.turnNumber,\r\n      timestamp: Date.now(),\r\n      reason: reason,\r\n      clientTurnNumber: this.game.turnNumber,\r\n      clientStateHash: calculateStateHash(this.game)\r\n    };\r\n    \r\n    this.sendToHost(resyncMsg);\r\n    console.log('[Client] Requested state resync:', reason);\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // HOST MONITORING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Start monitoring host liveness.\r\n   */\r\n  private startHostMonitoring(): void {\r\n    this.lastHostMessage = Date.now();\r\n    \r\n    this.hostAliveTimer = setInterval(() => {\r\n      const elapsed = Date.now() - this.lastHostMessage;\r\n      \r\n      if (elapsed > this.HOST_TIMEOUT) {\r\n        console.error('[Client] Host timeout - no messages for', elapsed, 'ms');\r\n        this.handleHostDisconnect();\r\n      }\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n  \r\n  /**\r\n   * Stop monitoring host.\r\n   */\r\n  private stopHostMonitoring(): void {\r\n    if (this.hostAliveTimer) {\r\n      clearInterval(this.hostAliveTimer);\r\n      this.hostAliveTimer = null;\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // DISCONNECT HANDLING\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Handle host disconnect.\r\n   */\r\n  private handleHostDisconnect(): void {\r\n    if (!this.connected) return;\r\n    \r\n    console.warn('[Client] Host disconnected');\r\n    this.connected = false;\r\n    this.stopHostMonitoring();\r\n    \r\n    this.emit('host-disconnected');\r\n    this.emit('disconnected', 'Host disconnected');\r\n    \r\n    // Attempt reconnection\r\n    this.attemptReconnect();\r\n  }\r\n  \r\n  /**\r\n   * Attempt to reconnect to host.\r\n   */\r\n  private attemptReconnect(): void {\r\n    if (this.reconnectAttempts >= this.MAX_RECONNECT_ATTEMPTS) {\r\n      console.error('[Client] Max reconnect attempts reached');\r\n      this.emit('error', new Error('Failed to reconnect to host'));\r\n      this.cleanup();\r\n      return;\r\n    }\r\n    \r\n    this.reconnectAttempts++;\r\n    console.log(`[Client] Reconnect attempt ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS}`);\r\n    this.emit('reconnecting');\r\n    \r\n    this.reconnectTimer = setTimeout(async () => {\r\n      try {\r\n        await this.connectToHost(10000);\r\n        await this.sendJoinRequest();\r\n        \r\n        this.connected = true;\r\n        this.reconnectAttempts = 0;\r\n        this.startHostMonitoring();\r\n        \r\n        console.log('[Client] Reconnected successfully');\r\n        this.emit('reconnected');\r\n        \r\n      } catch (error) {\r\n        console.error('[Client] Reconnect failed:', error);\r\n        this.attemptReconnect(); // Try again\r\n      }\r\n    }, this.RECONNECT_DELAY);\r\n  }\r\n  \r\n  /**\r\n   * Disconnect from room.\r\n   */\r\n  disconnect(): void {\r\n    console.log('[Client] Disconnecting');\r\n    \r\n    this.connected = false;\r\n    this.connecting = false;\r\n    \r\n    this.stopHostMonitoring();\r\n    \r\n    if (this.reconnectTimer) {\r\n      clearTimeout(this.reconnectTimer);\r\n      this.reconnectTimer = null;\r\n    }\r\n    \r\n    this.cleanup();\r\n    \r\n    this.emit('disconnected', 'User disconnected');\r\n  }\r\n  \r\n  /**\r\n   * Clean up resources.\r\n   */\r\n  private cleanup(): void {\r\n    // Close host connection\r\n    if (this.hostConnection) {\r\n      try {\r\n        this.hostConnection.close();\r\n      } catch (err) {\r\n        console.error('[Client] Error closing host connection:', err);\r\n      }\r\n      this.hostConnection = null;\r\n    }\r\n    \r\n    // Destroy peer\r\n    if (this.peer) {\r\n      try {\r\n        this.peer.destroy();\r\n      } catch (err) {\r\n        console.error('[Client] Error destroying peer:', err);\r\n      }\r\n      this.peer = null;\r\n    }\r\n    \r\n    // Clear pending actions\r\n    this.pendingActions.forEach((pending) => {\r\n      pending.reject(new Error('Disconnected'));\r\n    });\r\n    this.pendingActions.clear();\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // MESSAGING HELPERS\r\n  // ==========================================================================\r\n  \r\n  private sendToHost(message: any): void {\r\n    if (this.hostConnection) {\r\n      try {\r\n        this.hostConnection.send(message);\r\n      } catch (err) {\r\n        console.error('[Client] Failed to send to host:', err);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n  \r\n  /**\r\n   * Get current game state (read-only).\r\n   */\r\n  getGame(): Game | null {\r\n    return this.game;\r\n  }\r\n  \r\n  /**\r\n   * Get connection status.\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connected;\r\n  }\r\n  \r\n  /**\r\n   * Get client info.\r\n   */\r\n  getClientInfo(): ClientRoomInfo | null {\r\n    if (!this.game) return null;\r\n    \r\n    return {\r\n      roomCode: this.roomCode,\r\n      gameId: this.game.id,\r\n      hostPeerId: this.hostPeerId,\r\n      playerId: this.playerId,\r\n      playerName: this.playerName,\r\n      connected: this.connected,\r\n      connectedAt: this.connected ? Date.now() : undefined\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Join room with host peer ID (alternative method).\r\n   * Use this when you have the full host peer ID.\r\n   */\r\n  async joinRoomWithPeerId(\r\n    roomCode: string,\r\n    hostPeerId: string,\r\n    playerId: string,\r\n    playerName: string,\r\n    timeout: number = 60000\r\n  ): Promise<ClientRoomInfo> {\r\n    // Cache the peer ID for future connections\r\n    this.cacheHostPeerId(roomCode, hostPeerId);\r\n    \r\n    // Store host peer ID\r\n    this.hostPeerId = hostPeerId;\r\n    \r\n    // Join normally\r\n    return this.joinRoom(roomCode, playerId, playerName, timeout);\r\n  }\r\n  \r\n  /**\r\n   * Cache host peer ID to localStorage.\r\n   */\r\n  private cacheHostPeerId(roomCode: string, peerId: string): void {\r\n    try {\r\n      if (typeof localStorage === 'undefined') return;\r\n      \r\n      const data = {\r\n        peerId,\r\n        timestamp: Date.now()\r\n      };\r\n      \r\n      localStorage.setItem(`host_peer_${roomCode}`, JSON.stringify(data));\r\n    } catch (err) {\r\n      console.warn('[Client] Failed to cache host peer ID:', err);\r\n    }\r\n  }\r\n  \r\n  // ==========================================================================\r\n  // EVENT SYSTEM\r\n  // ==========================================================================\r\n  \r\n  on<K extends keyof ClientEventMap>(event: K, listener: ClientEventMap[K]): void {\r\n    if (!this.eventListeners.has(event)) {\r\n      this.eventListeners.set(event, new Set());\r\n    }\r\n    this.eventListeners.get(event)!.add(listener as Function);\r\n  }\r\n  \r\n  off<K extends keyof ClientEventMap>(event: K, listener: ClientEventMap[K]): void {\r\n    const listeners = this.eventListeners.get(event);\r\n    if (listeners) {\r\n      listeners.delete(listener as Function);\r\n    }\r\n  }\r\n  \r\n  private emit<K extends keyof ClientEventMap>(\r\n    event: K,\r\n    ...args: Parameters<ClientEventMap[K]>\r\n  ): void {\r\n    const listeners = this.eventListeners.get(event);\r\n    if (listeners) {\r\n      listeners.forEach(listener => {\r\n        try {\r\n          listener(...args);\r\n        } catch (err) {\r\n          console.error('[Client] Event listener error:', err);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport default P2PGameClient;\r\n"],"names":["shuffleArray","array","random","result","i","length","j","Math","floor","createNewGame","players","seed","Error","Set","map","p","id","size","state","charCodeAt","abs","createSeededRandom","allPointCards","cards","idCounter","emptyCrystals","CrystalColor","Yellow","Green","Red","Blue","push","points","cost","bonusCrystals","createPointCardDeck","shuffledPointCards","pointCardRow","slice","card","index","pointCardDeck","merchantDeck","type","MerchantCardType","Produce","produces","Upgrade","upgrades","count","times","Trade","gives","receives","createMerchantDeck","shuffledMerchantCards","merchantRow","remainingMerchantDeck","gamePlayers","playerInput","isFirst","startingCrystals","name","hand","playerId","playArea","caravan","pointCards","score","isFirstPlayer","now","Date","substring","phase","GamePhase","Setup","currentPlayerIndex","maxSize","turnNumber","endGameTriggered","endGameTriggerPlayerIndex","finalRoundComplete","winnerId","createdAt","updatedAt","P2PMessageType","P2PMessageFactory","createJoinGame","gameId","senderId","playerName","clientVersion","lastKnownTurn","messageId","this","generateMessageId","timestamp","createGameState","hostId","game","reason","lastAction","errorMessage","createActionRequest","action","expectedNextTurn","createActionResult","requestMessageId","success","newTurnNumber","errorCode","createError","severity","message","willDisconnect","causedByMessageId","details","toString","calculateStateHash","criticalState","c","sort","merchantDeckSize","pointCardDeckSize","str","hash","padStart","simpleHash","JSON","stringify","MessageDeduplicator","constructor","maxAge","seenMessages","messageTimestamps","Map","shouldProcess","msgId","has","console","log","add","set","cleanup","toRemove","forEach","delete","clear","ClientResyncManager","pendingResync","lastResyncRequest","minResyncInterval","shouldRequestResync","markResyncRequested","markResyncCompleted","reset","HostResyncManager","resyncCount","maxResyncsPerMinute","canClientResync","clientPeerId","get","recordResync","resetCounters","ClientStateSyncHandler","hostPeerId","localGame","deduplicator","resyncManager","handleGameState","verification","receivedState","error","valid","localHash","remoteHash","turnMatches","stateHash","turnValidation","messageTurn","currentTurn","diff","validateTurnNumber","warn","verifyGameState","requestResync","isResyncResponse","lastReceivedTurn","currentGame","substr","createResyncRequest","getLocalGame","HostStateSyncHandler","setInterval","handleResyncRequest","request","clientTurnNumber","clientStateHash","hostHash","GameState","resyncRequestId","updateGame","newGame","P2PGameRoom","peer","roomCode","syncHandler","connectedPeers","playerConnections","observers","config","observerModeEnabled","autoSkipTimers","PEER_RECONNECT_GRACE_PERIOD","isProcessingAction","eventListeners","createRoom","playerNames","observerMode","generateRoomCode","idx","generateSeed","toLowerCase","initializePeerHost","roomInfo","playerCount","connectedPlayers","gamePhase","emit","saveRoomToLocalStorage","chars","code","Promise","resolve","reject","timeout","setTimeout","destroy","Peer","host","port","path","secure","debug","iceServers","urls","username","credential","err","clearTimeout","on","conn","handleIncomingConnection","setupPeerListeners","errorMsg","String","reconnect","info","localStorage","roomData","savedAt","setItem","setupConnectionListeners","data","handlePeerMessage","handlePeerDisconnect","peerId","JoinGame","handleJoinRequest","ActionRequest","handleActionRequest","msg","sendError","handleObserverJoin","availablePlayer","find","playerInfo","connected","connectedAt","Playing","sendGameState","broadcastPlayerStatus","observerMsg","sendToPeer","sendActionResult","processAction","validation","validateAction","applyAction","turnResult","advanceTurn","gameFinished","finalizeGame","broadcastGameState","stateMsg","send","disconnectedPlayer","player","disconnectTime","handleCurrentPlayerDisconnect","timer","autoSkipTurn","restAction","handlePlayerReconnect","response","close","status","statusMsg","getRoomCode","getHostPeerId","getGame","getRoomInfo","getConnectedPlayerCount","getConnectedPlayers","Array","from","values","endMsg","event","listener","off","listeners","args","P2PGameClient","hostConnection","connecting","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","reconnectTimer","RECONNECT_DELAY","hostAliveTimer","lastHostMessage","HOST_TIMEOUT","pendingActions","ACTION_TIMEOUT","joinRoom","toUpperCase","initializePeerClient","discoverHostPeerId","connectToHost","sendJoinRequest","waitForInitialState","startHostMonitoring","cached","getCachedHostPeerId","getItem","parse","timeoutTimer","connect","reliable","serialization","handleHostMessage","handleHostDisconnect","joinMsg","sendToHost","handler","ActionResult","handleActionResult","handleError","handleResyncResponse","handlePlayerStatus","handleGameEnded","pending","disconnect","sendAction","requestMsg","resyncMsg","elapsed","stopHostMonitoring","clearInterval","attemptReconnect","async","isConnected","getClientInfo","joinRoomWithPeerId","cacheHostPeerId"],"mappings":"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"}