{"version":3,"file":"engine-CCVkibka.js","sources":["../../src/types/domain.ts","../../src/engine/turnSystem.ts","../../src/engine/validation.ts","../../src/engine/actionResolver.ts","../../src/engine/endgame.ts"],"sourcesContent":["/**\r\n * CENTURY: GOLEM EDITION - DOMAIN TYPES\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * This file defines the complete game state structure designed for\r\n * server-authoritative async multiplayer gameplay.\r\n * \r\n * Key Design Principles:\r\n * 1. FULL SERIALIZABILITY: All types are JSON-serializable (no functions, classes, or symbols)\r\n * 2. IMMUTABILITY: State transitions create new objects, never mutate existing state\r\n * 3. DETERMINISM: Same action + same state = same result (no randomness after setup)\r\n * 4. IDEMPOTENCY: Action timestamps enable deduplication at API layer\r\n * 5. RESUMABILITY: Game can be saved/loaded at any point without state loss\r\n * \r\n * Actions are Commands (not Events):\r\n * - Each action contains all data needed to execute (no external lookups)\r\n * - Actions are validated before application\r\n * - One action = one atomic state transition\r\n * - No reliance on timing or order (except turn-based validation)\r\n * \r\n * State Management:\r\n * - `Game` type represents complete game state snapshot\r\n * - `timestamp` fields (createdAt, updatedAt) are milliseconds since epoch\r\n * - All IDs are strings for easy serialization and comparison\r\n * - Null represents explicit absence (e.g., empty card slots)\r\n */\r\n\r\n// ============================================================================\r\n// ENUMS\r\n// ============================================================================\r\n\r\nexport enum CrystalColor {\r\n  Yellow = 'YELLOW',\r\n  Green = 'GREEN',\r\n  Red = 'RED',\r\n  Blue = 'BLUE'\r\n}\r\n\r\nexport enum GamePhase {\r\n  Setup = 'SETUP',\r\n  Playing = 'PLAYING',\r\n  Finished = 'FINISHED'\r\n}\r\n\r\nexport enum ActionType {\r\n  PlayMerchantCard = 'PLAY_MERCHANT_CARD',\r\n  AcquireMerchantCard = 'ACQUIRE_MERCHANT_CARD',\r\n  ClaimPointCard = 'CLAIM_POINT_CARD',\r\n  Rest = 'REST'\r\n}\r\n\r\nexport enum MerchantCardType {\r\n  Produce = 'PRODUCE',\r\n  Upgrade = 'UPGRADE',\r\n  Trade = 'TRADE'\r\n}\r\n\r\n// ============================================================================\r\n// CRYSTALS\r\n// ============================================================================\r\n\r\nexport type CrystalSet = {\r\n  [CrystalColor.Yellow]: number;\r\n  [CrystalColor.Green]: number;\r\n  [CrystalColor.Red]: number;\r\n  [CrystalColor.Blue]: number;\r\n};\r\n\r\n// ============================================================================\r\n// MERCHANT CARDS\r\n// ============================================================================\r\n\r\nexport type ProduceMerchantCard = {\r\n  id: string;\r\n  type: MerchantCardType.Produce;\r\n  produces: CrystalSet;\r\n};\r\n\r\nexport type UpgradeMerchantCard = {\r\n  id: string;\r\n  type: MerchantCardType.Upgrade;\r\n  upgrades: Array<{\r\n    count: number;\r\n    times: number;\r\n  }>;\r\n};\r\n\r\nexport type TradeMerchantCard = {\r\n  id: string;\r\n  type: MerchantCardType.Trade;\r\n  gives: CrystalSet;\r\n  receives: CrystalSet;\r\n};\r\n\r\nexport type MerchantCard = ProduceMerchantCard | UpgradeMerchantCard | TradeMerchantCard;\r\n\r\n// ============================================================================\r\n// POINT CARDS\r\n// ============================================================================\r\n\r\nexport type PointCard = {\r\n  id: string;\r\n  points: number;\r\n  cost: CrystalSet;\r\n  bonusCrystals: CrystalSet;\r\n};\r\n\r\n// ============================================================================\r\n// PLAYER\r\n// ============================================================================\r\n\r\nexport type Player = {\r\n  id: string;\r\n  name: string;\r\n  hand: MerchantCard[];\r\n  playArea: MerchantCard[];\r\n  caravan: CrystalSet;\r\n  pointCards: PointCard[];\r\n  score: number;\r\n  isFirstPlayer: boolean;\r\n};\r\n\r\n// ============================================================================\r\n// GAME STATE\r\n// ============================================================================\r\n\r\nexport type MerchantCardRow = {\r\n  cards: (MerchantCard | null)[];\r\n  maxSize: number;\r\n};\r\n\r\nexport type PointCardRow = {\r\n  cards: (PointCard | null)[];\r\n  maxSize: number;\r\n};\r\n\r\n/**\r\n * Complete game state - fully serializable and resumable.\r\n * \r\n * ASYNC SAFETY NOTES:\r\n * - This is the ONLY source of truth for game state\r\n * - All fields are primitives, arrays, or nested serializable objects\r\n * - timestamps are Unix epoch milliseconds (number, not Date objects)\r\n * - Can be JSON.stringify'd and restored without data loss\r\n * - No circular references or non-serializable types\r\n */\r\nexport type Game = {\r\n  id: string;\r\n  phase: GamePhase;\r\n  players: Player[];\r\n  currentPlayerIndex: number;\r\n  merchantDeck: MerchantCard[];\r\n  merchantRow: MerchantCardRow;\r\n  pointCardDeck: PointCard[];\r\n  pointCardRow: PointCardRow;\r\n  turnNumber: number;\r\n  endGameTriggered: boolean;\r\n  endGameTriggerPlayerIndex: number | null;\r\n  finalRoundComplete: boolean;\r\n  winnerId: string | null;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n};\r\n\r\n// ============================================================================\r\n// ACTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Base action interface - all actions must identify the player.\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * - `timestamp`: Used for idempotency checks at API layer\r\n *   (server can reject duplicate actions with same playerId + timestamp)\r\n * - `playerId`: Links action to player for authorization and validation\r\n * - `type`: Discriminator for TypeScript union type narrowing\r\n * \r\n * Actions are self-contained commands:\r\n * - Include ALL data needed to execute (cardId, payment, etc.)\r\n * - No server-side lookups or external state dependencies\r\n * - Can be queued, retried, or replayed without side effects\r\n */\r\nexport type BaseAction = {\r\n  type: ActionType;\r\n  playerId: string;\r\n  timestamp: number;\r\n};\r\n\r\n/**\r\n * Play a merchant card from hand to the play area.\r\n * \r\n * For Produce cards: No additional data needed.\r\n * For Trade cards: Crystals to give are specified by card definition.\r\n * For Upgrade cards: Must specify which crystals to upgrade.\r\n */\r\nexport type PlayCardAction = {\r\n  type: ActionType.PlayMerchantCard;\r\n  playerId: string;\r\n  timestamp: number;\r\n  cardId: string;\r\n  upgradeSelection?: CrystalUpgradeSelection;\r\n};\r\n\r\n/**\r\n * Specifies which crystals to upgrade and to what color.\r\n * Required when playing an Upgrade card.\r\n */\r\nexport type CrystalUpgradeSelection = {\r\n  upgrades: Array<{\r\n    fromColor: CrystalColor;\r\n    toColor: CrystalColor;\r\n  }>;\r\n};\r\n\r\n/**\r\n * Acquire a merchant card from the market row.\r\n * \r\n * Cost: Place 1 yellow crystal on each card to the left of the acquired card.\r\n * The acquired card goes to the player's hand.\r\n */\r\nexport type AcquireCardAction = {\r\n  type: ActionType.AcquireMerchantCard;\r\n  playerId: string;\r\n  timestamp: number;\r\n  rowIndex: number;\r\n  cardId: string;\r\n};\r\n\r\n/**\r\n * Claim a point card from the market row.\r\n * \r\n * Must pay the exact cost in crystals.\r\n * Receives bonus crystals if specified on the card.\r\n */\r\nexport type ClaimPointAction = {\r\n  type: ActionType.ClaimPointCard;\r\n  playerId: string;\r\n  timestamp: number;\r\n  rowIndex: number;\r\n  cardId: string;\r\n  payment: CrystalSet;\r\n};\r\n\r\n/**\r\n * Rest action - pick up all played merchant cards back into hand.\r\n * \r\n * This is the only way to reuse merchant cards that have been played.\r\n * No cost or additional data required.\r\n */\r\nexport type RestAction = {\r\n  type: ActionType.Rest;\r\n  playerId: string;\r\n  timestamp: number;\r\n};\r\n\r\n/**\r\n * Discriminated union of all possible game actions.\r\n * \r\n * ASYNC MULTIPLAYER GUARANTEES:\r\n * 1. DETERMINISTIC: Same action applied to same state always produces same result\r\n * 2. ATOMIC: Each action is a single state transition (no partial updates)\r\n * 3. VALIDATABLE: Can check if action is legal before applying\r\n * 4. SERIALIZABLE: All action data is JSON-safe (no functions or classes)\r\n * 5. IDEMPOTENT: Server can detect and reject duplicate submissions via timestamp\r\n * \r\n * Action Processing Flow:\r\n * 1. Client sends action to server\r\n * 2. Server validates action against current game state\r\n * 3. If valid, server applies action (pure function, no side effects)\r\n * 4. Server stores new state and broadcasts to all players\r\n * 5. Clients update local state when they receive broadcast\r\n * \r\n * No Race Conditions:\r\n * - Server processes actions sequentially per game\r\n * - Turn-based validation ensures only current player can act\r\n * - Failed actions don't modify state (validation before application)\r\n */\r\nexport type GameAction = \r\n  | PlayCardAction \r\n  | AcquireCardAction \r\n  | ClaimPointAction \r\n  | RestAction;\r\n\r\n// ============================================================================\r\n// GAME CONFIGURATION\r\n// ============================================================================\r\n\r\nexport type GameConfig = {\r\n  playerCount: number;\r\n  caravanCapacity: number;\r\n  merchantRowSize: number;\r\n  pointCardRowSize: number;\r\n  pointCardsToTriggerEnd: number;\r\n};\r\n\r\n// ============================================================================\r\n// ACTION RESULT\r\n// ============================================================================\r\n\r\nexport type ActionResult = {\r\n  success: boolean;\r\n  error?: string;\r\n  updatedGame?: Game;\r\n};\r\n","/**\r\n * TURN SYSTEM - Turn-based multiplayer state machine\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * This module manages turn order and prevents out-of-turn actions.\r\n * Essential for ensuring fairness in async multiplayer games.\r\n * \r\n * Key Properties:\r\n * 1. DETERMINISTIC: Turn order is fixed based on player array\r\n * 2. STATELESS: No timers, no external dependencies\r\n * 3. FAIR: All players get equal opportunities to act\r\n * 4. SEQUENTIAL: Only one player can act at a time\r\n * 5. NO TIMING: Turn doesn't auto-advance (player actions required)\r\n * \r\n * Turn-Based Model Benefits:\r\n * - Eliminates race conditions (only current player can act)\r\n * - No time pressure (turns don't expire)\r\n * - Players can reconnect and resume without penalty\r\n * - Simple state: currentPlayerIndex determines whose turn it is\r\n * - No synchronization needed between clients\r\n * \r\n * Server Usage:\r\n * ```typescript\r\n * // Before processing any action:\r\n * const turnCheck = validateTurn(gameState, action.playerId);\r\n * if (!turnCheck.valid) {\r\n *   return error('Not your turn', 403);\r\n * }\r\n * \r\n * // After action completes successfully:\r\n * const result = advanceTurn(gameState);\r\n * const newState = result.game; // Now next player's turn\r\n * ```\r\n * \r\n * Async Safety:\r\n * - Turn validation prevents concurrent actions\r\n * - Server processes actions sequentially per game\r\n * - Players wait for their turn (no time-based advancement)\r\n * - State changes are atomic (one turn = one state update)\r\n */\r\n\r\nimport { Game, GamePhase } from '../types/domain';\r\n\r\n// ============================================================================\r\n// TURN VALIDATION\r\n// ============================================================================\r\n\r\nexport type TurnValidationResult = {\r\n  valid: boolean;\r\n  error?: string;\r\n};\r\n\r\n/**\r\n * Validates if a player can take an action on their turn.\r\n * \r\n * Checks:\r\n * - Game must be in Playing phase\r\n * - Player must exist in the game\r\n * - Player must be the current active player\r\n * - Game must not be finished\r\n * \r\n * @param game - Current game state\r\n * @param playerId - ID of player attempting to act\r\n * @returns Validation result with error message if invalid\r\n */\r\nexport function validateTurn(game: Game, playerId: string): TurnValidationResult {\r\n  // Check game phase\r\n  if (game.phase === GamePhase.Setup) {\r\n    return {\r\n      valid: false,\r\n      error: 'Game is still in setup phase'\r\n    };\r\n  }\r\n\r\n  if (game.phase === GamePhase.Finished) {\r\n    return {\r\n      valid: false,\r\n      error: 'Game has already finished'\r\n    };\r\n  }\r\n\r\n  // Verify player exists\r\n  const player = game.players.find(p => p.id === playerId);\r\n  if (!player) {\r\n    return {\r\n      valid: false,\r\n      error: `Player ${playerId} not found in game`\r\n    };\r\n  }\r\n\r\n  // Check if it's the player's turn\r\n  const currentPlayer = game.players[game.currentPlayerIndex];\r\n  if (currentPlayer.id !== playerId) {\r\n    return {\r\n      valid: false,\r\n      error: `Not ${player.name}'s turn. Current turn: ${currentPlayer.name}`\r\n    };\r\n  }\r\n\r\n  // All checks passed\r\n  return { valid: true };\r\n}\r\n\r\n// ============================================================================\r\n// TURN ADVANCEMENT\r\n// ============================================================================\r\n\r\nexport type TurnAdvancementResult = {\r\n  game: Game;\r\n  turnEnded: boolean;\r\n  roundCompleted: boolean;\r\n  endGameTriggered: boolean;\r\n  gameFinished: boolean;\r\n};\r\n\r\n/**\r\n * Advances the game to the next player's turn.\r\n * \r\n * Turn order:\r\n * - Moves clockwise through players array\r\n * - Wraps back to player 0 after last player\r\n * - Increments turn number on each advancement\r\n * - Tracks rounds (one round = all players take one turn)\r\n * \r\n * End game logic:\r\n * - Triggers when a player reaches the required number of point cards\r\n * - Does NOT immediately end the game\r\n * - All players get one final turn after trigger\r\n * - Game ends when returning to the trigger player\r\n * \r\n * @param game - Current game state\r\n * @returns New game state with advanced turn and metadata about what changed\r\n */\r\nexport function advanceTurn(game: Game): TurnAdvancementResult {\r\n  // Cannot advance turn if game is not in playing phase\r\n  if (game.phase !== GamePhase.Playing) {\r\n    return {\r\n      game,\r\n      turnEnded: false,\r\n      roundCompleted: false,\r\n      endGameTriggered: false,\r\n      gameFinished: false\r\n    };\r\n  }\r\n\r\n  // Move to next player (clockwise)\r\n  const nextPlayerIndex = (game.currentPlayerIndex + 1) % game.players.length;\r\n  const roundCompleted = nextPlayerIndex === 0;\r\n\r\n  // Check if we're triggering end game\r\n  const currentPlayer = game.players[game.currentPlayerIndex];\r\n  const shouldTriggerEndGame = \r\n    !game.endGameTriggered && \r\n    currentPlayer.pointCards.length >= getPointCardsToTriggerEnd(game.players.length);\r\n\r\n  // Check if game should finish\r\n  // Game finishes when we return to the player who triggered the end game\r\n  const shouldFinishGame = \r\n    game.endGameTriggered && \r\n    game.endGameTriggerPlayerIndex !== null &&\r\n    nextPlayerIndex === game.endGameTriggerPlayerIndex;\r\n\r\n  // Create updated game state\r\n  const updatedGame: Game = {\r\n    ...game,\r\n    currentPlayerIndex: nextPlayerIndex,\r\n    turnNumber: game.turnNumber + 1,\r\n    endGameTriggered: game.endGameTriggered || shouldTriggerEndGame,\r\n    endGameTriggerPlayerIndex: shouldTriggerEndGame \r\n      ? game.currentPlayerIndex \r\n      : game.endGameTriggerPlayerIndex,\r\n    finalRoundComplete: shouldFinishGame,\r\n    phase: shouldFinishGame ? GamePhase.Finished : game.phase,\r\n    updatedAt: Date.now()\r\n  };\r\n\r\n  // Calculate final scores if game is finished\r\n  if (shouldFinishGame) {\r\n    const playersWithScores = calculateFinalScores(updatedGame);\r\n    const winner = determineWinner(playersWithScores);\r\n\r\n    return {\r\n      game: {\r\n        ...updatedGame,\r\n        players: playersWithScores,\r\n        winnerId: winner.id\r\n      },\r\n      turnEnded: true,\r\n      roundCompleted,\r\n      endGameTriggered: false,\r\n      gameFinished: true\r\n    };\r\n  }\r\n\r\n  return {\r\n    game: updatedGame,\r\n    turnEnded: true,\r\n    roundCompleted,\r\n    endGameTriggered: shouldTriggerEndGame,\r\n    gameFinished: false\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Returns the number of point cards required to trigger end game.\r\n * \r\n * Rules:\r\n * - 2-3 players: 4 point cards\r\n * - 4-5 players: 5 point cards\r\n */\r\nfunction getPointCardsToTriggerEnd(playerCount: number): number {\r\n  return playerCount >= 4 ? 5 : 4;\r\n}\r\n\r\n/**\r\n * Calculates final scores for all players.\r\n * \r\n * Score components:\r\n * - Points from claimed point cards (including coin bonuses)\r\n * - Bonus points from remaining crystals (1 point per 3 crystals)\r\n * \r\n * @param game - Game state at end\r\n * @returns Players with updated score values\r\n */\r\nfunction calculateFinalScores(game: Game): Game['players'] {\r\n  return game.players.map(player => {\r\n    // Sum points from all point cards\r\n    const pointCardScore = player.pointCards.reduce((sum, card) => sum + card.points, 0);\r\n\r\n    // Calculate bonus points from remaining crystals\r\n    const totalCrystals = \r\n      player.caravan.YELLOW +\r\n      player.caravan.GREEN +\r\n      player.caravan.RED +\r\n      player.caravan.BLUE;\r\n    const crystalBonus = Math.floor(totalCrystals / 3);\r\n\r\n    const finalScore = pointCardScore + crystalBonus;\r\n\r\n    return {\r\n      ...player,\r\n      score: finalScore\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Determines the winner from a list of players.\r\n * \r\n * Tiebreaker rules (in order):\r\n * 1. Highest score\r\n * 2. Most crystals remaining\r\n * 3. Most merchant cards in hand\r\n * 4. Player who went later in turn order (higher index)\r\n * \r\n * @param players - Array of players with calculated scores\r\n * @returns The winning player\r\n */\r\nfunction determineWinner(players: Game['players']): Game['players'][0] {\r\n  let winner = players[0];\r\n\r\n  for (let i = 1; i < players.length; i++) {\r\n    const challenger = players[i];\r\n\r\n    // Compare scores\r\n    if (challenger.score > winner.score) {\r\n      winner = challenger;\r\n      continue;\r\n    }\r\n    if (challenger.score < winner.score) {\r\n      continue;\r\n    }\r\n\r\n    // Tie on score - check crystal count\r\n    const winnerCrystals = \r\n      winner.caravan.YELLOW + \r\n      winner.caravan.GREEN + \r\n      winner.caravan.RED + \r\n      winner.caravan.BLUE;\r\n    const challengerCrystals = \r\n      challenger.caravan.YELLOW + \r\n      challenger.caravan.GREEN + \r\n      challenger.caravan.RED + \r\n      challenger.caravan.BLUE;\r\n\r\n    if (challengerCrystals > winnerCrystals) {\r\n      winner = challenger;\r\n      continue;\r\n    }\r\n    if (challengerCrystals < winnerCrystals) {\r\n      continue;\r\n    }\r\n\r\n    // Tie on crystals - check merchant card count\r\n    const winnerMerchantCount = winner.hand.length + winner.playArea.length;\r\n    const challengerMerchantCount = challenger.hand.length + challenger.playArea.length;\r\n\r\n    if (challengerMerchantCount > winnerMerchantCount) {\r\n      winner = challenger;\r\n      continue;\r\n    }\r\n    if (challengerMerchantCount < winnerMerchantCount) {\r\n      continue;\r\n    }\r\n\r\n    // Tie on merchant cards - player who went later wins (higher turn order)\r\n    // Since we're iterating forward, challenger automatically wins this tiebreaker\r\n    winner = challenger;\r\n  }\r\n\r\n  return winner;\r\n}\r\n\r\n// ============================================================================\r\n// TURN STATE QUERIES\r\n// ============================================================================\r\n\r\n/**\r\n * Gets the current active player from game state.\r\n * \r\n * @param game - Current game state\r\n * @returns The player whose turn it is, or null if game is not in Playing phase\r\n */\r\nexport function getCurrentPlayer(game: Game): Game['players'][0] | null {\r\n  if (game.phase !== GamePhase.Playing) {\r\n    return null;\r\n  }\r\n  return game.players[game.currentPlayerIndex];\r\n}\r\n\r\n/**\r\n * Checks if the game is in the final round (end game triggered but not finished).\r\n * \r\n * @param game - Current game state\r\n * @returns True if in final round, false otherwise\r\n */\r\nexport function isInFinalRound(game: Game): boolean {\r\n  return game.endGameTriggered && !game.finalRoundComplete;\r\n}\r\n\r\n/**\r\n * Gets the number of turns remaining before game ends.\r\n * Returns null if end game has not been triggered.\r\n * \r\n * @param game - Current game state\r\n * @returns Number of turns until game ends, or null if not in final round\r\n */\r\nexport function getTurnsUntilGameEnd(game: Game): number | null {\r\n  if (!game.endGameTriggered || game.endGameTriggerPlayerIndex === null) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate how many players need to take their final turn\r\n  const triggerIndex = game.endGameTriggerPlayerIndex;\r\n  const currentIndex = game.currentPlayerIndex;\r\n  \r\n  if (currentIndex <= triggerIndex) {\r\n    return triggerIndex - currentIndex;\r\n  } else {\r\n    // Wrapped around\r\n    return game.players.length - currentIndex + triggerIndex;\r\n  }\r\n}\r\n","import {\r\n  Game,\r\n  GameAction,\r\n  PlayCardAction,\r\n  AcquireCardAction,\r\n  ClaimPointAction,\r\n  RestAction,\r\n  ActionType,\r\n  CrystalColor,\r\n  CrystalSet,\r\n  MerchantCardType,\r\n  Player\r\n} from '../types/domain';\r\nimport { validateTurn } from './turnSystem';\r\n\r\n// ============================================================================\r\n// VALIDATION RESULT TYPES\r\n// ============================================================================\r\n\r\nexport type ValidationSuccess = {\r\n  valid: true;\r\n};\r\n\r\nexport type ValidationError = {\r\n  valid: false;\r\n  error: string;\r\n  code: ValidationErrorCode;\r\n};\r\n\r\nexport type ValidationResult = ValidationSuccess | ValidationError;\r\n\r\nexport enum ValidationErrorCode {\r\n  // Turn validation\r\n  InvalidTurn = 'INVALID_TURN',\r\n  GameNotPlaying = 'GAME_NOT_PLAYING',\r\n  \r\n  // Card validation\r\n  CardNotFound = 'CARD_NOT_FOUND',\r\n  CardNotInHand = 'CARD_NOT_IN_HAND',\r\n  InvalidRowIndex = 'INVALID_ROW_INDEX',\r\n  \r\n  // Resource validation\r\n  InsufficientCrystals = 'INSUFFICIENT_CRYSTALS',\r\n  CaravanCapacityExceeded = 'CARAVAN_CAPACITY_EXCEEDED',\r\n  IncorrectPayment = 'INCORRECT_PAYMENT',\r\n  \r\n  // Action-specific validation\r\n  InvalidUpgradeSelection = 'INVALID_UPGRADE_SELECTION',\r\n  NoCardsToRest = 'NO_CARDS_TO_REST',\r\n  InvalidUpgradePath = 'INVALID_UPGRADE_PATH',\r\n  UpgradeCountMismatch = 'UPGRADE_COUNT_MISMATCH',\r\n  \r\n  // General\r\n  InvalidActionType = 'INVALID_ACTION_TYPE'\r\n}\r\n\r\n// ============================================================================\r\n// MAIN VALIDATION DISPATCHER\r\n// ============================================================================\r\n\r\n/**\r\n * Validates any game action against the current game state.\r\n * Routes to specific validator based on action type.\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * - PURE FUNCTION: No side effects, reads game state only\r\n * - DETERMINISTIC: Same state + action = same result always\r\n * - THREAD-SAFE: Can be called concurrently for different games\r\n * - FAST: Returns immediately without async operations\r\n * \r\n * Server should call this BEFORE applying action:\r\n * ```\r\n * const validation = validateAction(currentState, clientAction);\r\n * if (!validation.valid) {\r\n *   return error(validation.error, validation.code);\r\n * }\r\n * const newState = applyAction(currentState, clientAction);\r\n * await saveGameState(newState);\r\n * ```\r\n * \r\n * This ensures:\r\n * - Invalid actions never corrupt game state\r\n * - Clients get immediate feedback on action legality\r\n * - Server maintains single source of truth\r\n * \r\n * @param game - Current game state (not modified)\r\n * @param action - Action to validate\r\n * @returns Validation result with error details if invalid\r\n */\r\nexport function validateAction(game: Game, action: GameAction): ValidationResult {\r\n  // First validate turn ownership\r\n  const turnValidation = validateTurn(game, action.playerId);\r\n  if (!turnValidation.valid) {\r\n    return {\r\n      valid: false,\r\n      error: turnValidation.error!,\r\n      code: ValidationErrorCode.InvalidTurn\r\n    };\r\n  }\r\n\r\n  // Route to specific validator\r\n  switch (action.type) {\r\n    case ActionType.PlayMerchantCard:\r\n      return validatePlayCard(game, action);\r\n    case ActionType.AcquireMerchantCard:\r\n      return validateAcquireCard(game, action);\r\n    case ActionType.ClaimPointCard:\r\n      return validateClaimPoint(game, action);\r\n    case ActionType.Rest:\r\n      return validateRest(game, action);\r\n    default:\r\n      return {\r\n        valid: false,\r\n        error: 'Unknown action type',\r\n        code: ValidationErrorCode.InvalidActionType\r\n      };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// PLAY CARD VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validates playing a merchant card from hand.\r\n * \r\n * Rules:\r\n * - Card must be in player's hand\r\n * - For Produce: Check caravan capacity after production\r\n * - For Trade: Must have required crystals, check capacity after trade\r\n * - For Upgrade: Must have valid upgrade selection matching card requirements\r\n * \r\n * @param game - Current game state\r\n * @param action - Play card action\r\n * @returns Validation result\r\n */\r\nexport function validatePlayCard(game: Game, action: PlayCardAction): ValidationResult {\r\n  const player = getPlayer(game, action.playerId);\r\n  if (!player) {\r\n    return error('Player not found', ValidationErrorCode.CardNotFound);\r\n  }\r\n\r\n  // Check card is in hand\r\n  const card = player.hand.find(c => c.id === action.cardId);\r\n  if (!card) {\r\n    return error(\r\n      `Card ${action.cardId} not found in player's hand`,\r\n      ValidationErrorCode.CardNotInHand\r\n    );\r\n  }\r\n\r\n  // Validate based on card type\r\n  switch (card.type) {\r\n    case MerchantCardType.Produce:\r\n      return validateProduceCard(player, card.produces);\r\n    \r\n    case MerchantCardType.Trade:\r\n      return validateTradeCard(player, card.gives, card.receives);\r\n    \r\n    case MerchantCardType.Upgrade:\r\n      return validateUpgradeCard(player, card, action.upgradeSelection);\r\n    \r\n    default:\r\n      return error('Unknown card type', ValidationErrorCode.InvalidActionType);\r\n  }\r\n}\r\n\r\n/**\r\n * Validates producing crystals.\r\n * Checks if caravan has capacity for produced crystals.\r\n */\r\nfunction validateProduceCard(player: Player, produces: CrystalSet): ValidationResult {\r\n  const currentTotal = countTotalCrystals(player.caravan);\r\n  const producedTotal = countTotalCrystals(produces);\r\n  \r\n  if (currentTotal + producedTotal > 10) {\r\n    return error(\r\n      `Cannot produce ${producedTotal} crystals. Caravan capacity: ${currentTotal}/10`,\r\n      ValidationErrorCode.CaravanCapacityExceeded\r\n    );\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n/**\r\n * Validates trading crystals.\r\n * Checks player has crystals to give and capacity for received crystals.\r\n */\r\nfunction validateTradeCard(\r\n  player: Player,\r\n  gives: CrystalSet,\r\n  receives: CrystalSet\r\n): ValidationResult {\r\n  // Check player has crystals to give\r\n  if (!hasEnoughCrystals(player.caravan, gives)) {\r\n    return error(\r\n      `Insufficient crystals to trade. Required: ${formatCrystalSet(gives)}`,\r\n      ValidationErrorCode.InsufficientCrystals\r\n    );\r\n  }\r\n\r\n  // Calculate resulting caravan after trade\r\n  const afterTrade = subtractCrystals(player.caravan, gives);\r\n  const finalCaravan = addCrystals(afterTrade, receives);\r\n  const finalTotal = countTotalCrystals(finalCaravan);\r\n\r\n  if (finalTotal > 10) {\r\n    return error(\r\n      `Trade would exceed caravan capacity. Result: ${finalTotal}/10`,\r\n      ValidationErrorCode.CaravanCapacityExceeded\r\n    );\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n/**\r\n * Validates upgrading crystals.\r\n * \r\n * Rules:\r\n * - Must provide upgrade selection for upgrade cards\r\n * - Number of upgrades must match card requirements\r\n * - Each upgrade must follow valid color progression (Y→G→R→B)\r\n * - Player must have the crystals being upgraded\r\n * - Cannot exceed caravan capacity (shouldn't happen with upgrades)\r\n */\r\nfunction validateUpgradeCard(\r\n  player: Player,\r\n  card: { upgrades: Array<{ count: number; times: number }> },\r\n  selection?: { upgrades: Array<{ fromColor: CrystalColor; toColor: CrystalColor }> }\r\n): ValidationResult {\r\n  if (!selection || !selection.upgrades) {\r\n    return error(\r\n      'Upgrade selection required for upgrade cards',\r\n      ValidationErrorCode.InvalidUpgradeSelection\r\n    );\r\n  }\r\n\r\n  // Calculate total upgrades required by card\r\n  const totalUpgradesRequired = card.upgrades.reduce(\r\n    (sum, upgrade) => sum + (upgrade.count * upgrade.times),\r\n    0\r\n  );\r\n\r\n  if (selection.upgrades.length !== totalUpgradesRequired) {\r\n    return error(\r\n      `Upgrade count mismatch. Required: ${totalUpgradesRequired}, provided: ${selection.upgrades.length}`,\r\n      ValidationErrorCode.UpgradeCountMismatch\r\n    );\r\n  }\r\n\r\n  // Validate each upgrade is valid\r\n  const caravan = { ...player.caravan };\r\n  \r\n  for (const upgrade of selection.upgrades) {\r\n    // Check valid upgrade path\r\n    if (!isValidUpgradePath(upgrade.fromColor, upgrade.toColor)) {\r\n      return error(\r\n        `Invalid upgrade path: ${upgrade.fromColor} → ${upgrade.toColor}`,\r\n        ValidationErrorCode.InvalidUpgradePath\r\n      );\r\n    }\r\n\r\n    // Check player has crystal to upgrade\r\n    if (caravan[upgrade.fromColor] <= 0) {\r\n      return error(\r\n        `Insufficient ${upgrade.fromColor} crystals to upgrade`,\r\n        ValidationErrorCode.InsufficientCrystals\r\n      );\r\n    }\r\n\r\n    // Apply upgrade to temporary caravan for validation\r\n    caravan[upgrade.fromColor]--;\r\n    caravan[upgrade.toColor]++;\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n/**\r\n * Checks if an upgrade path is valid.\r\n * Valid paths: Yellow→Green, Green→Red, Red→Blue\r\n */\r\nfunction isValidUpgradePath(from: CrystalColor, to: CrystalColor): boolean {\r\n  const validPaths: Record<CrystalColor, CrystalColor[]> = {\r\n    [CrystalColor.Yellow]: [CrystalColor.Green],\r\n    [CrystalColor.Green]: [CrystalColor.Red],\r\n    [CrystalColor.Red]: [CrystalColor.Blue],\r\n    [CrystalColor.Blue]: []\r\n  };\r\n\r\n  return validPaths[from]?.includes(to) ?? false;\r\n}\r\n\r\n// ============================================================================\r\n// ACQUIRE CARD VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validates acquiring a merchant card from the market.\r\n * \r\n * Rules:\r\n * - Row index must be valid (0 to merchantRow.maxSize - 1)\r\n * - Card must exist at that position\r\n * - Card ID must match (validation cross-check)\r\n * - Player must have enough yellow crystals for cost (1 per card to the left)\r\n * \r\n * @param game - Current game state\r\n * @param action - Acquire card action\r\n * @returns Validation result\r\n */\r\nexport function validateAcquireCard(game: Game, action: AcquireCardAction): ValidationResult {\r\n  const player = getPlayer(game, action.playerId);\r\n  if (!player) {\r\n    return error('Player not found', ValidationErrorCode.CardNotFound);\r\n  }\r\n\r\n  // Validate row index\r\n  if (action.rowIndex < 0 || action.rowIndex >= game.merchantRow.maxSize) {\r\n    return error(\r\n      `Invalid row index: ${action.rowIndex}. Must be 0-${game.merchantRow.maxSize - 1}`,\r\n      ValidationErrorCode.InvalidRowIndex\r\n    );\r\n  }\r\n\r\n  // Check card exists at position\r\n  const card = game.merchantRow.cards[action.rowIndex];\r\n  if (!card) {\r\n    return error(\r\n      `No card at position ${action.rowIndex}`,\r\n      ValidationErrorCode.CardNotFound\r\n    );\r\n  }\r\n\r\n  // Verify card ID matches\r\n  if (card.id !== action.cardId) {\r\n    return error(\r\n      `Card ID mismatch at position ${action.rowIndex}`,\r\n      ValidationErrorCode.CardNotFound\r\n    );\r\n  }\r\n\r\n  // Calculate cost: 1 yellow crystal per card to the left\r\n  const cost = action.rowIndex;\r\n  if (player.caravan[CrystalColor.Yellow] < cost) {\r\n    return error(\r\n      `Insufficient yellow crystals. Required: ${cost}, have: ${player.caravan[CrystalColor.Yellow]}`,\r\n      ValidationErrorCode.InsufficientCrystals\r\n    );\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n// ============================================================================\r\n// CLAIM POINT VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validates claiming a point card from the market.\r\n * \r\n * Rules:\r\n * - Row index must be valid (0 to pointCardRow.maxSize - 1)\r\n * - Card must exist at that position\r\n * - Card ID must match (validation cross-check)\r\n * - Payment must exactly match card cost\r\n * - Player must have the crystals to pay\r\n * - After payment, player still within caravan capacity (bonus crystals)\r\n * \r\n * @param game - Current game state\r\n * @param action - Claim point action\r\n * @returns Validation result\r\n */\r\nexport function validateClaimPoint(game: Game, action: ClaimPointAction): ValidationResult {\r\n  const player = getPlayer(game, action.playerId);\r\n  if (!player) {\r\n    return error('Player not found', ValidationErrorCode.CardNotFound);\r\n  }\r\n\r\n  // Validate row index\r\n  if (action.rowIndex < 0 || action.rowIndex >= game.pointCardRow.maxSize) {\r\n    return error(\r\n      `Invalid row index: ${action.rowIndex}. Must be 0-${game.pointCardRow.maxSize - 1}`,\r\n      ValidationErrorCode.InvalidRowIndex\r\n    );\r\n  }\r\n\r\n  // Check card exists at position\r\n  const card = game.pointCardRow.cards[action.rowIndex];\r\n  if (!card) {\r\n    return error(\r\n      `No card at position ${action.rowIndex}`,\r\n      ValidationErrorCode.CardNotFound\r\n    );\r\n  }\r\n\r\n  // Verify card ID matches\r\n  if (card.id !== action.cardId) {\r\n    return error(\r\n      `Card ID mismatch at position ${action.rowIndex}`,\r\n      ValidationErrorCode.CardNotFound\r\n    );\r\n  }\r\n\r\n  // Verify payment matches cost exactly\r\n  if (!crystalSetsEqual(action.payment, card.cost)) {\r\n    return error(\r\n      `Payment does not match cost. Required: ${formatCrystalSet(card.cost)}, provided: ${formatCrystalSet(action.payment)}`,\r\n      ValidationErrorCode.IncorrectPayment\r\n    );\r\n  }\r\n\r\n  // Check player has crystals to pay\r\n  if (!hasEnoughCrystals(player.caravan, card.cost)) {\r\n    return error(\r\n      `Insufficient crystals to pay. Required: ${formatCrystalSet(card.cost)}`,\r\n      ValidationErrorCode.InsufficientCrystals\r\n    );\r\n  }\r\n\r\n  // Check caravan capacity after payment and receiving bonus\r\n  const afterPayment = subtractCrystals(player.caravan, card.cost);\r\n  const afterBonus = addCrystals(afterPayment, card.bonusCrystals);\r\n  const finalTotal = countTotalCrystals(afterBonus);\r\n\r\n  if (finalTotal > 10) {\r\n    return error(\r\n      `Would exceed caravan capacity after bonus crystals. Result: ${finalTotal}/10`,\r\n      ValidationErrorCode.CaravanCapacityExceeded\r\n    );\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n// ============================================================================\r\n// REST VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validates resting (picking up played cards).\r\n * \r\n * Rules:\r\n * - Player must have at least one card in play area\r\n * \r\n * @param game - Current game state\r\n * @param action - Rest action\r\n * @returns Validation result\r\n */\r\nexport function validateRest(game: Game, action: RestAction): ValidationResult {\r\n  const player = getPlayer(game, action.playerId);\r\n  if (!player) {\r\n    return error('Player not found', ValidationErrorCode.CardNotFound);\r\n  }\r\n\r\n  if (player.playArea.length === 0) {\r\n    return error(\r\n      'No cards in play area to rest',\r\n      ValidationErrorCode.NoCardsToRest\r\n    );\r\n  }\r\n\r\n  return success();\r\n}\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\nfunction getPlayer(game: Game, playerId: string): Player | undefined {\r\n  return game.players.find(p => p.id === playerId);\r\n}\r\n\r\nfunction success(): ValidationSuccess {\r\n  return { valid: true };\r\n}\r\n\r\nfunction error(message: string, code: ValidationErrorCode): ValidationError {\r\n  return { valid: false, error: message, code };\r\n}\r\n\r\nfunction countTotalCrystals(crystals: CrystalSet): number {\r\n  return crystals.YELLOW + crystals.GREEN + crystals.RED + crystals.BLUE;\r\n}\r\n\r\nfunction hasEnoughCrystals(caravan: CrystalSet, required: CrystalSet): boolean {\r\n  return (\r\n    caravan.YELLOW >= required.YELLOW &&\r\n    caravan.GREEN >= required.GREEN &&\r\n    caravan.RED >= required.RED &&\r\n    caravan.BLUE >= required.BLUE\r\n  );\r\n}\r\n\r\nfunction crystalSetsEqual(a: CrystalSet, b: CrystalSet): boolean {\r\n  return (\r\n    a.YELLOW === b.YELLOW &&\r\n    a.GREEN === b.GREEN &&\r\n    a.RED === b.RED &&\r\n    a.BLUE === b.BLUE\r\n  );\r\n}\r\n\r\nfunction addCrystals(base: CrystalSet, toAdd: CrystalSet): CrystalSet {\r\n  return {\r\n    YELLOW: base.YELLOW + toAdd.YELLOW,\r\n    GREEN: base.GREEN + toAdd.GREEN,\r\n    RED: base.RED + toAdd.RED,\r\n    BLUE: base.BLUE + toAdd.BLUE\r\n  };\r\n}\r\n\r\nfunction subtractCrystals(base: CrystalSet, toSubtract: CrystalSet): CrystalSet {\r\n  return {\r\n    YELLOW: base.YELLOW - toSubtract.YELLOW,\r\n    GREEN: base.GREEN - toSubtract.GREEN,\r\n    RED: base.RED - toSubtract.RED,\r\n    BLUE: base.BLUE - toSubtract.BLUE\r\n  };\r\n}\r\n\r\nfunction formatCrystalSet(crystals: CrystalSet): string {\r\n  const parts: string[] = [];\r\n  if (crystals.YELLOW > 0) parts.push(`${crystals.YELLOW}Y`);\r\n  if (crystals.GREEN > 0) parts.push(`${crystals.GREEN}G`);\r\n  if (crystals.RED > 0) parts.push(`${crystals.RED}R`);\r\n  if (crystals.BLUE > 0) parts.push(`${crystals.BLUE}B`);\r\n  return parts.length > 0 ? parts.join(', ') : 'none';\r\n}\r\n","/**\r\n * ACTION RESOLUTION LAYER\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * This layer applies validated actions to produce new game states.\r\n * All functions are PURE - no side effects, no mutations, no I/O.\r\n * \r\n * Key Properties:\r\n * 1. IMMUTABILITY: Never modifies input state, always returns new state\r\n * 2. DETERMINISM: Same action + state = same new state (always)\r\n * 3. PURE FUNCTIONS: No side effects, external calls, or randomness\r\n * 4. ATOMIC: Each function is a single state transition\r\n * 5. RESUMABLE: Can apply actions to any saved state snapshot\r\n * \r\n * State Transition Model:\r\n * ```\r\n * oldState + action -> newState\r\n * ```\r\n * \r\n * Server Usage Pattern:\r\n * ```typescript\r\n * // 1. Load state from database\r\n * const currentState = await loadGameState(gameId);\r\n * \r\n * // 2. Validate action (validation.ts)\r\n * const validation = validateAction(currentState, action);\r\n * if (!validation.valid) return error(validation.error);\r\n * \r\n * // 3. Apply action (this file)\r\n * const newState = applyAction(currentState, action);\r\n * \r\n * // 4. Save new state\r\n * await saveGameState(newState);\r\n * \r\n * // 5. Broadcast to all players\r\n * await broadcastStateUpdate(gameId, newState);\r\n * ```\r\n * \r\n * No Race Conditions:\r\n * - Server processes actions sequentially per game\r\n * - Each action sees consistent state snapshot\r\n * - State updates are atomic (old state -> new state)\r\n * - Failed validations don't reach this layer\r\n * \r\n * Idempotency:\r\n * - Apply same action twice to different states = different results\r\n * - BUT: Server can prevent duplicate actions via timestamp deduplication\r\n * - Action resolution itself is deterministic, not idempotent\r\n */\r\n\r\nimport {\r\n  Game,\r\n  GameAction,\r\n  PlayCardAction,\r\n  AcquireCardAction,\r\n  ClaimPointAction,\r\n  RestAction,\r\n  ActionType,\r\n  CrystalColor,\r\n  CrystalSet,\r\n  MerchantCardType,\r\n  MerchantCard,\r\n  Player\r\n} from '../types/domain';\r\n\r\n// ============================================================================\r\n// ACTION RESOLUTION\r\n// ============================================================================\r\n\r\n/**\r\n * Applies a validated action to the game state.\r\n * Returns a new game state with the action effects applied.\r\n * \r\n * IMPORTANT: This function assumes the action has already been validated.\r\n * It does NOT perform validation - use validateAction() first.\r\n * \r\n * ASYNC MULTIPLAYER GUARANTEES:\r\n * - PURE: No side effects, mutations, or I/O operations\r\n * - DETERMINISTIC: Same inputs always produce same output\r\n * - IMMUTABLE: Original game state is never modified\r\n * - ATOMIC: Complete state transition in one function call\r\n * - FAST: Synchronous, no async operations or delays\r\n * \r\n * State Transition Properties:\r\n * - Creates new Game object with all changes applied\r\n * - Updates `updatedAt` timestamp to current time\r\n * - Preserves all unchanged state (deep copy for modified parts)\r\n * - Returns valid serializable state ready for storage/broadcast\r\n * \r\n * @param game - Current game state (not modified)\r\n * @param action - Validated action to apply\r\n * @returns New game state with action effects applied\r\n */\r\nexport function applyAction(game: Game, action: GameAction): Game {\r\n  switch (action.type) {\r\n    case ActionType.PlayMerchantCard:\r\n      return applyPlayCard(game, action);\r\n    case ActionType.AcquireMerchantCard:\r\n      return applyAcquireCard(game, action);\r\n    case ActionType.ClaimPointCard:\r\n      return applyClaimPoint(game, action);\r\n    case ActionType.Rest:\r\n      return applyRest(game, action);\r\n    default:\r\n      return game;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// PLAY CARD RESOLUTION\r\n// ============================================================================\r\n\r\n/**\r\n * Applies playing a merchant card from hand.\r\n * \r\n * Rules:\r\n * 1. Move card from player's hand to play area\r\n * 2. Apply card effect based on type:\r\n *    - Produce: Add crystals to caravan\r\n *    - Trade: Remove 'gives' crystals, add 'receives' crystals\r\n *    - Upgrade: Transform crystals according to selection\r\n * \r\n * @param game - Current game state\r\n * @param action - Play card action\r\n * @returns New game state\r\n */\r\nexport function applyPlayCard(game: Game, action: PlayCardAction): Game {\r\n  const playerIndex = game.players.findIndex(p => p.id === action.playerId);\r\n  const player = game.players[playerIndex];\r\n\r\n  // Find and remove card from hand\r\n  const cardIndex = player.hand.findIndex(c => c.id === action.cardId);\r\n  const card = player.hand[cardIndex];\r\n  \r\n  const newHand = [\r\n    ...player.hand.slice(0, cardIndex),\r\n    ...player.hand.slice(cardIndex + 1)\r\n  ];\r\n\r\n  // Add card to play area\r\n  const newPlayArea = [...player.playArea, card];\r\n\r\n  // Apply card effect to caravan\r\n  let newCaravan = { ...player.caravan };\r\n\r\n  switch (card.type) {\r\n    case MerchantCardType.Produce:\r\n      // Rule: Add produced crystals to caravan\r\n      newCaravan = addCrystals(newCaravan, card.produces);\r\n      break;\r\n\r\n    case MerchantCardType.Trade:\r\n      // Rule: Remove 'gives' crystals, add 'receives' crystals\r\n      newCaravan = subtractCrystals(newCaravan, card.gives);\r\n      newCaravan = addCrystals(newCaravan, card.receives);\r\n      break;\r\n\r\n    case MerchantCardType.Upgrade:\r\n      // Rule: Transform crystals according to player's upgrade selection\r\n      if (action.upgradeSelection) {\r\n        for (const upgrade of action.upgradeSelection.upgrades) {\r\n          newCaravan[upgrade.fromColor]--;\r\n          newCaravan[upgrade.toColor]++;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n\r\n  // Create updated player\r\n  const updatedPlayer: Player = {\r\n    ...player,\r\n    hand: newHand,\r\n    playArea: newPlayArea,\r\n    caravan: newCaravan\r\n  };\r\n\r\n  // Create new players array\r\n  const newPlayers = [\r\n    ...game.players.slice(0, playerIndex),\r\n    updatedPlayer,\r\n    ...game.players.slice(playerIndex + 1)\r\n  ];\r\n\r\n  return {\r\n    ...game,\r\n    players: newPlayers,\r\n    updatedAt: Date.now()\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// ACQUIRE CARD RESOLUTION\r\n// ============================================================================\r\n\r\n/**\r\n * Applies acquiring a merchant card from the market.\r\n * \r\n * Rules:\r\n * 1. Remove card from merchant row at specified index\r\n * 2. Add card to player's hand\r\n * 3. Pay cost: Place 1 yellow crystal on each card to the LEFT\r\n * 4. Refill merchant row from deck (shift cards left, add new card at end)\r\n * \r\n * @param game - Current game state\r\n * @param action - Acquire card action\r\n * @returns New game state\r\n */\r\nexport function applyAcquireCard(game: Game, action: AcquireCardAction): Game {\r\n  const playerIndex = game.players.findIndex(p => p.id === action.playerId);\r\n  const player = game.players[playerIndex];\r\n\r\n  // Get the acquired card\r\n  const acquiredCard = game.merchantRow.cards[action.rowIndex]!;\r\n\r\n  // Rule: Pay 1 yellow crystal per card to the left of acquired card\r\n  const cost = action.rowIndex;\r\n  let newCaravan = { ...player.caravan };\r\n  newCaravan[CrystalColor.Yellow] -= cost;\r\n\r\n  // Rule: Place paid crystals on cards to the left\r\n  // Note: These crystals go on the cards, which players collect when acquiring them\r\n  // For now, crystals are simply removed from player (they don't go anywhere permanent)\r\n\r\n  // Add acquired card to player's hand\r\n  const newHand = [...player.hand, acquiredCard];\r\n\r\n  // Update player\r\n  const updatedPlayer: Player = {\r\n    ...player,\r\n    hand: newHand,\r\n    caravan: newCaravan\r\n  };\r\n\r\n  // Rule: Remove card from merchant row and refill\r\n  // Remove acquired card (set to null temporarily)\r\n  let newMerchantCards = [...game.merchantRow.cards];\r\n  newMerchantCards[action.rowIndex] = null;\r\n\r\n  // Shift all cards left to fill gaps\r\n  const compactedCards = newMerchantCards.filter(c => c !== null) as MerchantCard[];\r\n\r\n  // Refill from deck to maintain row size\r\n  let newDeck = [...game.merchantDeck];\r\n  const cardsNeeded = game.merchantRow.maxSize - compactedCards.length;\r\n  \r\n  for (let i = 0; i < cardsNeeded && newDeck.length > 0; i++) {\r\n    compactedCards.push(newDeck[0]);\r\n    newDeck = newDeck.slice(1);\r\n  }\r\n\r\n  // Pad with nulls if deck is exhausted\r\n  while (compactedCards.length < game.merchantRow.maxSize) {\r\n    compactedCards.push(null as any);\r\n  }\r\n\r\n  // Create new players array\r\n  const newPlayers = [\r\n    ...game.players.slice(0, playerIndex),\r\n    updatedPlayer,\r\n    ...game.players.slice(playerIndex + 1)\r\n  ];\r\n\r\n  return {\r\n    ...game,\r\n    players: newPlayers,\r\n    merchantDeck: newDeck,\r\n    merchantRow: {\r\n      ...game.merchantRow,\r\n      cards: compactedCards\r\n    },\r\n    updatedAt: Date.now()\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// CLAIM POINT RESOLUTION\r\n// ============================================================================\r\n\r\n/**\r\n * Applies claiming a point card from the market.\r\n * \r\n * Rules:\r\n * 1. Remove point card from row at specified index\r\n * 2. Pay exact cost in crystals from caravan\r\n * 3. Add point card to player's claimed cards\r\n * 4. Receive bonus crystals (if any) specified on card\r\n * 5. Refill point card row from deck (shift left, add new card at end)\r\n * \r\n * @param game - Current game state\r\n * @param action - Claim point action\r\n * @returns New game state\r\n */\r\nexport function applyClaimPoint(game: Game, action: ClaimPointAction): Game {\r\n  const playerIndex = game.players.findIndex(p => p.id === action.playerId);\r\n  const player = game.players[playerIndex];\r\n\r\n  // Get the claimed card\r\n  const claimedCard = game.pointCardRow.cards[action.rowIndex]!;\r\n\r\n  // Rule: Pay the exact cost\r\n  let newCaravan = subtractCrystals(player.caravan, claimedCard.cost);\r\n\r\n  // Rule: Receive bonus crystals (if any)\r\n  newCaravan = addCrystals(newCaravan, claimedCard.bonusCrystals);\r\n\r\n  // Add point card to player's collection\r\n  const newPointCards = [...player.pointCards, claimedCard];\r\n\r\n  // Update player\r\n  const updatedPlayer: Player = {\r\n    ...player,\r\n    caravan: newCaravan,\r\n    pointCards: newPointCards\r\n  };\r\n\r\n  // Rule: Remove card from point card row and refill\r\n  let newPointCards_row = [...game.pointCardRow.cards];\r\n  newPointCards_row[action.rowIndex] = null;\r\n\r\n  // Shift all cards left to fill gaps\r\n  const compactedCards = newPointCards_row.filter(c => c !== null);\r\n\r\n  // Refill from deck to maintain row size\r\n  let newPointDeck = [...game.pointCardDeck];\r\n  const cardsNeeded = game.pointCardRow.maxSize - compactedCards.length;\r\n  \r\n  for (let i = 0; i < cardsNeeded && newPointDeck.length > 0; i++) {\r\n    compactedCards.push(newPointDeck[0]);\r\n    newPointDeck = newPointDeck.slice(1);\r\n  }\r\n\r\n  // Pad with nulls if deck is exhausted\r\n  while (compactedCards.length < game.pointCardRow.maxSize) {\r\n    compactedCards.push(null as any);\r\n  }\r\n\r\n  // Create new players array\r\n  const newPlayers = [\r\n    ...game.players.slice(0, playerIndex),\r\n    updatedPlayer,\r\n    ...game.players.slice(playerIndex + 1)\r\n  ];\r\n\r\n  return {\r\n    ...game,\r\n    players: newPlayers,\r\n    pointCardDeck: newPointDeck,\r\n    pointCardRow: {\r\n      ...game.pointCardRow,\r\n      cards: compactedCards\r\n    },\r\n    updatedAt: Date.now()\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// REST RESOLUTION\r\n// ============================================================================\r\n\r\n/**\r\n * Applies resting (recovering all played cards).\r\n * \r\n * Rules:\r\n * 1. Move ALL cards from play area back to hand\r\n * 2. This is the only way to reuse merchant cards\r\n * 3. No cost, no other effects\r\n * \r\n * @param game - Current game state\r\n * @param action - Rest action\r\n * @returns New game state\r\n */\r\nexport function applyRest(game: Game, action: RestAction): Game {\r\n  const playerIndex = game.players.findIndex(p => p.id === action.playerId);\r\n  const player = game.players[playerIndex];\r\n\r\n  // Rule: Move all cards from play area to hand\r\n  const newHand = [...player.hand, ...player.playArea];\r\n  const newPlayArea: MerchantCard[] = [];\r\n\r\n  // Update player\r\n  const updatedPlayer: Player = {\r\n    ...player,\r\n    hand: newHand,\r\n    playArea: newPlayArea\r\n  };\r\n\r\n  // Create new players array\r\n  const newPlayers = [\r\n    ...game.players.slice(0, playerIndex),\r\n    updatedPlayer,\r\n    ...game.players.slice(playerIndex + 1)\r\n  ];\r\n\r\n  return {\r\n    ...game,\r\n    players: newPlayers,\r\n    updatedAt: Date.now()\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\nfunction addCrystals(base: CrystalSet, toAdd: CrystalSet): CrystalSet {\r\n  return {\r\n    YELLOW: base.YELLOW + toAdd.YELLOW,\r\n    GREEN: base.GREEN + toAdd.GREEN,\r\n    RED: base.RED + toAdd.RED,\r\n    BLUE: base.BLUE + toAdd.BLUE\r\n  };\r\n}\r\n\r\nfunction subtractCrystals(base: CrystalSet, toSubtract: CrystalSet): CrystalSet {\r\n  return {\r\n    YELLOW: base.YELLOW - toSubtract.YELLOW,\r\n    GREEN: base.GREEN - toSubtract.GREEN,\r\n    RED: base.RED - toSubtract.RED,\r\n    BLUE: base.BLUE - toSubtract.BLUE\r\n  };\r\n}\r\n","/**\r\n * ENDGAME SYSTEM - Game completion and scoring\r\n * \r\n * ASYNC MULTIPLAYER SAFETY:\r\n * This module handles game ending conditions and final scoring.\r\n * All calculations are deterministic and based on game state only.\r\n * \r\n * Key Properties:\r\n * 1. DETERMINISTIC: Scoring is purely mathematical (no randomness)\r\n * 2. STATELESS: Only depends on game state, no external data\r\n * 3. FAIR: Tiebreaker rules ensure clear winner\r\n * 4. TRANSPARENT: All scoring rules visible in code\r\n * 5. FINAL: Game phase = Finished means no more actions accepted\r\n * \r\n * Endgame Flow:\r\n * 1. Player claims N-th point card -> endgame triggered\r\n * 2. All other players get one final turn\r\n * 3. finalizeGame() calculates scores and determines winner\r\n * 4. Game phase set to Finished\r\n * 5. No more actions accepted (validation will reject)\r\n * \r\n * Async Safety:\r\n * - Endgame detection happens during state transition\r\n * - Server tracks endGameTriggered flag\r\n * - Final turn enforcement via turnNumber comparison\r\n * - Winner determination is pure calculation\r\n * - Once Finished, state is immutable (validation rejects actions)\r\n * \r\n * Server Usage:\r\n * ```typescript\r\n * // After applying ClaimPoint action:\r\n * const trigger = checkEndGameTrigger(newState);\r\n * if (trigger.triggered && !newState.endGameTriggered) {\r\n *   newState.endGameTriggered = true;\r\n *   newState.endGameTriggerPlayerIndex = trigger.playerIndex;\r\n * }\r\n * \r\n * // After each turn in endgame:\r\n * if (isInFinalRound(newState) && nextPlayerIsTriggerer) {\r\n *   newState = finalizeGame(newState);\r\n * }\r\n * ```\r\n */\r\n\r\nimport { Game, Player, CrystalColor } from '../types/domain';\r\n\r\n// ============================================================================\r\n// ENDGAME CONSTANTS\r\n// ============================================================================\r\n\r\n/**\r\n * Number of point cards required to trigger endgame based on player count.\r\n */\r\nconst POINT_CARDS_TO_TRIGGER_END = {\r\n  2: 6,\r\n  3: 6,\r\n  4: 5,\r\n  5: 5\r\n} as const;\r\n\r\n/**\r\n * Point values for coins collected on point cards.\r\n */\r\nconst COIN_VALUES = {\r\n  COPPER: 3,\r\n  SILVER: 1\r\n} as const;\r\n\r\n/**\r\n * Point value for each non-yellow crystal at game end.\r\n */\r\nconst CRYSTAL_POINT_VALUE = 1;\r\n\r\n// ============================================================================\r\n// ENDGAME TRIGGER CHECK\r\n// ============================================================================\r\n\r\n/**\r\n * Checks if any player has triggered the endgame condition.\r\n * \r\n * Rules:\r\n * - 4-5 players: Game ends when a player claims their 5th point card\r\n * - 2-3 players: Game ends when a player claims their 6th point card\r\n * - After trigger, all players get one final turn\r\n * \r\n * @param game - Current game state\r\n * @returns Object with trigger status and triggering player if any\r\n */\r\nexport function checkEndGameTrigger(game: Game): {\r\n  triggered: boolean;\r\n  playerIndex: number | null;\r\n  playerName: string | null;\r\n} {\r\n  const requiredCards = getRequiredPointCards(game.players.length);\r\n\r\n  for (let i = 0; i < game.players.length; i++) {\r\n    const player = game.players[i];\r\n    if (player.pointCards.length >= requiredCards) {\r\n      return {\r\n        triggered: true,\r\n        playerIndex: i,\r\n        playerName: player.name\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    triggered: false,\r\n    playerIndex: null,\r\n    playerName: null\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the number of point cards required to trigger endgame.\r\n * \r\n * @param playerCount - Number of players in the game\r\n * @returns Number of point cards needed to trigger end\r\n */\r\nfunction getRequiredPointCards(playerCount: number): number {\r\n  return POINT_CARDS_TO_TRIGGER_END[playerCount as keyof typeof POINT_CARDS_TO_TRIGGER_END] || 6;\r\n}\r\n\r\n// ============================================================================\r\n// SCORE CALCULATION\r\n// ============================================================================\r\n\r\n/**\r\n * Calculates the final score for a player.\r\n * \r\n * Scoring components:\r\n * 1. Points from claimed point cards (base value)\r\n * 2. Copper coins: 3 points each\r\n * 3. Silver coins: 1 point each\r\n * 4. Non-yellow crystals: 1 point each (green, red, blue)\r\n * 5. Yellow crystals: 0 points\r\n * \r\n * Note: Coins are already added to point card values during setup/claiming.\r\n * This function recalculates from the point card's base points.\r\n * \r\n * @param player - Player to calculate score for\r\n * @returns Total score\r\n */\r\nexport function calculateScore(player: Player): number {\r\n  // Sum points from all claimed point cards\r\n  const pointCardScore = player.pointCards.reduce((sum, card) => {\r\n    return sum + card.points;\r\n  }, 0);\r\n\r\n  // Rule: Count non-yellow crystals (green, red, blue = 1 point each)\r\n  const crystalScore = \r\n    player.caravan[CrystalColor.Green] +\r\n    player.caravan[CrystalColor.Red] +\r\n    player.caravan[CrystalColor.Blue];\r\n  // Yellow crystals are worth 0 points\r\n\r\n  return pointCardScore + crystalScore;\r\n}\r\n\r\n/**\r\n * Calculates scores for all players and updates their score field.\r\n * \r\n * @param game - Game state at end\r\n * @returns Players array with updated scores\r\n */\r\nexport function calculateAllScores(game: Game): Player[] {\r\n  return game.players.map(player => ({\r\n    ...player,\r\n    score: calculateScore(player)\r\n  }));\r\n}\r\n\r\n// ============================================================================\r\n// GAME FINALIZATION\r\n// ============================================================================\r\n\r\n/**\r\n * Finalizes the game by calculating scores and determining the winner.\r\n * \r\n * Rules:\r\n * 1. Calculate final scores for all players\r\n * 2. Determine winner using tiebreaker rules\r\n * 3. Mark game as finished\r\n * \r\n * Tiebreaker rules (in order):\r\n * 1. Highest score\r\n * 2. Most total crystals remaining\r\n * 3. Most merchant cards (hand + play area)\r\n * 4. Last player in turn order wins (went later in final round)\r\n * \r\n * @param game - Game state after final round completes\r\n * @returns Final game state with winner determined\r\n */\r\nexport function finalizeGame(game: Game): Game {\r\n  // Calculate scores for all players\r\n  const playersWithScores = calculateAllScores(game);\r\n\r\n  // Determine winner using tiebreaker rules\r\n  const winner = determineWinner(playersWithScores);\r\n\r\n  return {\r\n    ...game,\r\n    players: playersWithScores,\r\n    winnerId: winner.id,\r\n    finalRoundComplete: true,\r\n    updatedAt: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * Determines the winner from players with calculated scores.\r\n * \r\n * Tiebreaker rules (in order):\r\n * 1. Highest score\r\n * 2. Most crystals remaining (all colors)\r\n * 3. Most merchant cards (hand + play area combined)\r\n * 4. Player who went later in turn order (higher array index)\r\n * \r\n * @param players - Array of players with calculated scores\r\n * @returns The winning player\r\n */\r\nexport function determineWinner(players: Player[]): Player {\r\n  // Create array with player indices for tie-breaking\r\n  const playersWithIndex = players.map((player, index) => ({\r\n    player,\r\n    index\r\n  }));\r\n\r\n  // Sort by tiebreaker rules\r\n  playersWithIndex.sort((a, b) => {\r\n    // Rule 1: Highest score wins\r\n    if (a.player.score !== b.player.score) {\r\n      return b.player.score - a.player.score;\r\n    }\r\n\r\n    // Rule 2: Most crystals wins\r\n    const aCrystals = getTotalCrystals(a.player);\r\n    const bCrystals = getTotalCrystals(b.player);\r\n    if (aCrystals !== bCrystals) {\r\n      return bCrystals - aCrystals;\r\n    }\r\n\r\n    // Rule 3: Most merchant cards wins\r\n    const aMerchantCards = a.player.hand.length + a.player.playArea.length;\r\n    const bMerchantCards = b.player.hand.length + b.player.playArea.length;\r\n    if (aMerchantCards !== bMerchantCards) {\r\n      return bMerchantCards - aMerchantCards;\r\n    }\r\n\r\n    // Rule 4: Player who went later (higher index) wins\r\n    return b.index - a.index;\r\n  });\r\n\r\n  return playersWithIndex[0].player;\r\n}\r\n\r\n// ============================================================================\r\n// ENDGAME QUERIES\r\n// ============================================================================\r\n\r\n/**\r\n * Checks if the game is in the final round.\r\n * \r\n * @param game - Current game state\r\n * @returns True if endgame triggered but not yet complete\r\n */\r\nexport function isInFinalRound(game: Game): boolean {\r\n  return game.endGameTriggered && !game.finalRoundComplete;\r\n}\r\n\r\n/**\r\n * Gets the number of turns remaining until game ends.\r\n * \r\n * @param game - Current game state\r\n * @returns Number of turns remaining, or null if endgame not triggered\r\n */\r\nexport function getRemainingTurns(game: Game): number | null {\r\n  if (!game.endGameTriggered || game.endGameTriggerPlayerIndex === null) {\r\n    return null;\r\n  }\r\n\r\n  const triggerIndex = game.endGameTriggerPlayerIndex;\r\n  const currentIndex = game.currentPlayerIndex;\r\n  const playerCount = game.players.length;\r\n\r\n  // Calculate turns until we return to trigger player\r\n  if (currentIndex <= triggerIndex) {\r\n    return triggerIndex - currentIndex;\r\n  } else {\r\n    return playerCount - currentIndex + triggerIndex;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets endgame status summary.\r\n * \r\n * @param game - Current game state\r\n * @returns Endgame status information\r\n */\r\nexport function getEndGameStatus(game: Game): {\r\n  triggered: boolean;\r\n  inFinalRound: boolean;\r\n  complete: boolean;\r\n  triggerPlayer: string | null;\r\n  turnsRemaining: number | null;\r\n  winner: string | null;\r\n} {\r\n  return {\r\n    triggered: game.endGameTriggered,\r\n    inFinalRound: isInFinalRound(game),\r\n    complete: game.finalRoundComplete,\r\n    triggerPlayer: game.endGameTriggerPlayerIndex !== null\r\n      ? game.players[game.endGameTriggerPlayerIndex].name\r\n      : null,\r\n    turnsRemaining: getRemainingTurns(game),\r\n    winner: game.winnerId\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Counts total crystals in a player's caravan.\r\n * \r\n * @param player - Player to count crystals for\r\n * @returns Total number of crystals\r\n */\r\nfunction getTotalCrystals(player: Player): number {\r\n  return (\r\n    player.caravan[CrystalColor.Yellow] +\r\n    player.caravan[CrystalColor.Green] +\r\n    player.caravan[CrystalColor.Red] +\r\n    player.caravan[CrystalColor.Blue]\r\n  );\r\n}\r\n\r\n/**\r\n * Gets a breakdown of a player's score for display.\r\n * Useful for showing score details to players.\r\n * \r\n * @param player - Player to get score breakdown for\r\n * @returns Object with score component breakdown\r\n */\r\nexport function getScoreBreakdown(player: Player): {\r\n  pointCards: number;\r\n  crystals: number;\r\n  total: number;\r\n  crystalBreakdown: {\r\n    yellow: number;\r\n    green: number;\r\n    red: number;\r\n    blue: number;\r\n  };\r\n} {\r\n  const pointCardScore = player.pointCards.reduce((sum, card) => sum + card.points, 0);\r\n  \r\n  const crystalBreakdown = {\r\n    yellow: player.caravan[CrystalColor.Yellow],\r\n    green: player.caravan[CrystalColor.Green],\r\n    red: player.caravan[CrystalColor.Red],\r\n    blue: player.caravan[CrystalColor.Blue]\r\n  };\r\n\r\n  const crystalScore = crystalBreakdown.green + crystalBreakdown.red + crystalBreakdown.blue;\r\n\r\n  return {\r\n    pointCards: pointCardScore,\r\n    crystals: crystalScore,\r\n    total: pointCardScore + crystalScore,\r\n    crystalBreakdown\r\n  };\r\n}\r\n"],"names":["CrystalColor","GamePhase","ActionType","MerchantCardType","advanceTurn","game","phase","Playing","turnEnded","roundCompleted","endGameTriggered","gameFinished","nextPlayerIndex","currentPlayerIndex","players","length","currentPlayer","shouldTriggerEndGame","pointCards","shouldFinishGame","endGameTriggerPlayerIndex","updatedGame","turnNumber","finalRoundComplete","Finished","updatedAt","Date","now","playersWithScores","map","player","pointCardScore","reduce","sum","card","points","totalCrystals","caravan","YELLOW","GREEN","RED","BLUE","finalScore","Math","floor","score","calculateFinalScores","winner","i","challenger","winnerCrystals","challengerCrystals","winnerMerchantCount","hand","playArea","challengerMerchantCount","determineWinner","winnerId","id","validateAction","action","turnValidation","playerId","Setup","valid","error","find","p","name","validateTurn","code","type","PlayMerchantCard","getPlayer","c","cardId","Produce","produces","currentTotal","countTotalCrystals","producedTotal","validateProduceCard","Trade","gives","receives","hasEnoughCrystals","formatCrystalSet","afterTrade","subtractCrystals","finalTotal","addCrystals","validateTradeCard","Upgrade","selection","upgrades","totalUpgradesRequired","upgrade","count","times","isValidUpgradePath","fromColor","toColor","validateUpgradeCard","upgradeSelection","validatePlayCard","AcquireMerchantCard","rowIndex","merchantRow","maxSize","cards","cost","Yellow","validateAcquireCard","ClaimPointCard","pointCardRow","a","payment","b","afterPayment","bonusCrystals","validateClaimPoint","Rest","validateRest","from","to","validPaths","Green","Red","Blue","includes","message","crystals","required","base","toAdd","toSubtract","parts","push","join","applyAction","playerIndex","findIndex","cardIndex","newHand","slice","newPlayArea","newCaravan","updatedPlayer","newPlayers","applyPlayCard","acquiredCard","newMerchantCards","compactedCards","filter","newDeck","merchantDeck","cardsNeeded","applyAcquireCard","claimedCard","newPointCards","newPointCards_row","newPointDeck","pointCardDeck","applyClaimPoint","applyRest","calculateScore","finalizeGame","calculateAllScores","playersWithIndex","index","sort","aCrystals","getTotalCrystals","bCrystals","aMerchantCards","bMerchantCards"],"mappings":"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"}