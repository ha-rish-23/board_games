import{$ as e}from"./peerjs-BtN9W7or.js";import{C as t,G as s,M as n,v as o,a as r,b as i,f as a}from"./engine-CCVkibka.js";function c(e,t){const s=[...e];for(let n=s.length-1;n>0;n--){const e=Math.floor(t()*(n+1));[s[n],s[e]]=[s[e],s[n]]}return s}function l(e,o){if(e.length<2||e.length>5)throw new Error(`Invalid player count: ${e.length}. Must be between 2 and 5.`);if(new Set(e.map(e=>e.id)).size!==e.length)throw new Error("Player IDs must be unique");const r=function(e){let t=0;for(let s=0;s<e.length;s++)t=(t<<5)-t+e.charCodeAt(s)|0;return t=Math.abs(t),function(){return t=1664525*t+1013904223|0,Math.abs(t)/2147483648}}(o),i=function(){const e=[];let s=1;const n=()=>({[t.Yellow]:0,[t.Green]:0,[t.Red]:0,[t.Blue]:0});return e.push({id:"p"+s++,points:6,cost:{...n(),[t.Green]:2,[t.Red]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:7,cost:{...n(),[t.Yellow]:2,[t.Red]:2},bonusCrystals:n()}),e.push({id:"p"+s++,points:8,cost:{...n(),[t.Green]:3,[t.Red]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:9,cost:{...n(),[t.Yellow]:3,[t.Green]:1,[t.Red]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:10,cost:{...n(),[t.Green]:2,[t.Red]:2},bonusCrystals:n()}),e.push({id:"p"+s++,points:11,cost:{...n(),[t.Yellow]:2,[t.Green]:2,[t.Red]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:12,cost:{...n(),[t.Green]:3,[t.Red]:2},bonusCrystals:n()}),e.push({id:"p"+s++,points:13,cost:{...n(),[t.Yellow]:3,[t.Green]:2,[t.Red]:1},bonusCrystals:{...n(),[t.Yellow]:1}}),e.push({id:"p"+s++,points:14,cost:{...n(),[t.Red]:3,[t.Blue]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:15,cost:{...n(),[t.Green]:3,[t.Red]:2,[t.Blue]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:16,cost:{...n(),[t.Yellow]:2,[t.Red]:3,[t.Blue]:1},bonusCrystals:{...n(),[t.Green]:1}}),e.push({id:"p"+s++,points:17,cost:{...n(),[t.Green]:4,[t.Red]:2,[t.Blue]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:18,cost:{...n(),[t.Red]:4,[t.Blue]:2},bonusCrystals:n()}),e.push({id:"p"+s++,points:19,cost:{...n(),[t.Green]:3,[t.Red]:3,[t.Blue]:2},bonusCrystals:{...n(),[t.Yellow]:2}}),e.push({id:"p"+s++,points:20,cost:{...n(),[t.Red]:3,[t.Blue]:3},bonusCrystals:n()}),e.push({id:"p"+s++,points:11,cost:{...n(),[t.Yellow]:4,[t.Green]:2},bonusCrystals:n()}),e.push({id:"p"+s++,points:12,cost:{...n(),[t.Yellow]:2,[t.Red]:2,[t.Blue]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:13,cost:{...n(),[t.Green]:2,[t.Red]:2,[t.Blue]:1},bonusCrystals:n()}),e.push({id:"p"+s++,points:14,cost:{...n(),[t.Yellow]:3,[t.Red]:3},bonusCrystals:{...n(),[t.Green]:1}}),e.push({id:"p"+s++,points:15,cost:{...n(),[t.Yellow]:2,[t.Green]:3,[t.Blue]:1},bonusCrystals:n()}),e}(),a=c(i,r),l=a.slice(0,5).map((e,t)=>3===t?{...e,points:e.points+1}:4===t?{...e,points:e.points+3}:e),d=a.slice(5),h=function(){const e=[];let s=1;const o=()=>({[t.Yellow]:0,[t.Green]:0,[t.Red]:0,[t.Blue]:0});e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:2}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:2}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:3}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:4}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Green]:1}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Green]:2}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:1,[t.Green]:1}}),e.push({id:"m"+s++,type:n.Produce,produces:{...o(),[t.Yellow]:2,[t.Green]:1}});for(let t=0;t<5;t++)e.push({id:"m"+s++,type:n.Upgrade,upgrades:[{count:2,times:1}]});for(let t=0;t<4;t++)e.push({id:"m"+s++,type:n.Upgrade,upgrades:[{count:3,times:1}]});for(let t=0;t<3;t++)e.push({id:"m"+s++,type:n.Upgrade,upgrades:[{count:1,times:2}]});e.push({id:"m"+s++,type:n.Upgrade,upgrades:[{count:2,times:2}]}),e.push({id:"m"+s++,type:n.Upgrade,upgrades:[{count:1,times:3}]});for(let r=0;r<2;r++)e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:2},receives:{...o(),[t.Green]:2}});e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:3},receives:{...o(),[t.Green]:3}});for(let r=0;r<2;r++)e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:2},receives:{...o(),[t.Red]:1}});e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:3},receives:{...o(),[t.Red]:2}});for(let r=0;r<2;r++)e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Green]:2},receives:{...o(),[t.Red]:2}});e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Green]:3},receives:{...o(),[t.Red]:3}}),e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:3},receives:{...o(),[t.Blue]:1}});for(let r=0;r<2;r++)e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Green]:2},receives:{...o(),[t.Blue]:1}});e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Green]:3},receives:{...o(),[t.Blue]:2}});for(let r=0;r<2;r++)e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Red]:2},receives:{...o(),[t.Blue]:2}});return e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Red]:3},receives:{...o(),[t.Blue]:3}}),e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:2,[t.Green]:1},receives:{...o(),[t.Red]:3}}),e.push({id:"m"+s++,type:n.Trade,gives:{...o(),[t.Yellow]:1,[t.Green]:2},receives:{...o(),[t.Blue]:2}}),e}(),m=c(h,r),u=m.slice(0,6),p=m.slice(6),g=e.map((e,s)=>{const o=0===s,r={[t.Yellow]:0,[t.Green]:0,[t.Red]:0,[t.Blue]:0};return r[t.Yellow]=o?3:4,{id:e.id,name:e.name,hand:(i=e.id,[{id:`start-${i}-1`,type:n.Produce,produces:{[t.Yellow]:0,[t.Green]:0,[t.Red]:0,[t.Blue]:0,[t.Yellow]:2}},{id:`start-${i}-2`,type:n.Upgrade,upgrades:[{count:2,times:1}]}]),playArea:[],caravan:r,pointCards:[],score:0,isFirstPlayer:o};var i});e.length,e.length;const y=Date.now();return{id:`game-${y}-${o.substring(0,8)}`,phase:s.Playing,players:g,currentPlayerIndex:0,merchantDeck:p,merchantRow:{cards:u,maxSize:6},pointCardDeck:d,pointCardRow:{cards:l,maxSize:5},turnNumber:1,endGameTriggered:!1,endGameTriggerPlayerIndex:null,finalRoundComplete:!1,winnerId:null,createdAt:y,updatedAt:y}}var d=(e=>(e.JoinGame="JOIN_GAME",e.GameState="GAME_STATE",e.ActionRequest="ACTION_REQUEST",e.ActionResult="ACTION_RESULT",e.Error="ERROR",e))(d||{});class h{static createJoinGame(e,t,s,n,o,r){return{type:"JOIN_GAME",messageId:this.generateMessageId(),gameId:e,senderId:t,turnNumber:r??0,timestamp:Date.now(),playerId:s,playerName:n,clientVersion:o,lastKnownTurn:r}}static createGameState(e,t,s,n,o,r){return{type:"GAME_STATE",messageId:this.generateMessageId(),gameId:e,senderId:t,turnNumber:s.turnNumber,timestamp:Date.now(),game:s,reason:n,lastAction:o,errorMessage:r}}static createActionRequest(e,t,s,n,o){return{type:"ACTION_REQUEST",messageId:this.generateMessageId(),gameId:e,senderId:t,turnNumber:s,timestamp:Date.now(),action:n,expectedNextTurn:o}}static createActionResult(e,t,s,n,o,r,i,a){return{type:"ACTION_RESULT",messageId:this.generateMessageId(),gameId:e,senderId:t,turnNumber:s,timestamp:Date.now(),requestMessageId:n,success:o,newTurnNumber:r,errorMessage:i,errorCode:a}}static createError(e,t,s,n,o,r,i=!1,a,c){return{type:"ERROR",messageId:this.generateMessageId(),gameId:e,senderId:t,turnNumber:s,timestamp:Date.now(),severity:n,errorCode:o,message:r,causedByMessageId:a,details:c,willDisconnect:i}}static generateMessageId(){const e=Math.random().toString(36).substring(2,9);return`${Date.now()}_${e}`}}function m(e){const t={id:e.id,phase:e.phase,turnNumber:e.turnNumber,currentPlayerIndex:e.currentPlayerIndex,players:e.players.map(e=>({id:e.id,name:e.name,hand:e.hand.map(e=>e.id).sort(),playArea:e.playArea.map(e=>e.id).sort(),caravan:{...e.caravan},pointCards:e.pointCards.map(e=>e.id).sort(),score:e.score,isFirstPlayer:e.isFirstPlayer})),merchantRow:e.merchantRow.cards.map(e=>e?e.id:null),merchantDeckSize:e.merchantDeck.length,pointCardDeckSize:e.pointCardDeck.length,pointCardRow:e.pointCardRow.cards.map(e=>e?e.id:null),endGameTriggered:e.endGameTriggered,endGameTriggerPlayerIndex:e.endGameTriggerPlayerIndex,finalRoundComplete:e.finalRoundComplete,winnerId:e.winnerId};return function(e){let t=0;for(let s=0;s<e.length;s++){t=(t<<5)-t+e.charCodeAt(s),t&=t}return Math.abs(t).toString(36).padStart(8,"0")}(JSON.stringify(t))}class u{constructor(e=6e4,t=1e3){this.seenMessages=new Set,this.messageTimestamps=new Map,this.maxAge=e,this.maxSize=t}shouldProcess(e){const t=e.messageId;return this.seenMessages.has(t)?(console.log(`[Dedup] Ignoring duplicate message: ${t}`),!1):(this.seenMessages.add(t),this.messageTimestamps.set(t,e.timestamp),this.cleanup(),!0)}cleanup(){if(this.seenMessages.size<this.maxSize)return;const e=Date.now(),t=[];this.messageTimestamps.forEach((s,n)=>{e-s>this.maxAge&&t.push(n)}),t.forEach(e=>{this.seenMessages.delete(e),this.messageTimestamps.delete(e)}),console.log(`[Dedup] Cleaned up ${t.length} old messages`)}clear(){this.seenMessages.clear(),this.messageTimestamps.clear()}}class p{constructor(){this.pendingResync=!1,this.lastResyncRequest=0,this.minResyncInterval=2e3}shouldRequestResync(){if(this.pendingResync)return console.log("[Resync] Already waiting for resync response"),!1;return!(Date.now()-this.lastResyncRequest<this.minResyncInterval)||(console.log("[Resync] Too soon since last request"),!1)}markResyncRequested(){this.pendingResync=!0,this.lastResyncRequest=Date.now()}markResyncCompleted(){this.pendingResync=!1,console.log("[Resync] State synchronized successfully")}reset(){this.pendingResync=!1,this.lastResyncRequest=0}}class g{constructor(){this.resyncCount=new Map,this.maxResyncsPerMinute=10}canClientResync(e){return(this.resyncCount.get(e)||0)<this.maxResyncsPerMinute}recordResync(e){const t=this.resyncCount.get(e)||0;this.resyncCount.set(e,t+1),console.log(`[Resync] Client ${e} requested resync (${t+1}/${this.maxResyncsPerMinute})`)}resetCounters(){this.resyncCount.clear()}}class y{constructor(e){this.localGame=null,this.hostPeerId=e,this.deduplicator=new u,this.resyncManager=new p}handleGameState(e){if(!this.deduplicator.shouldProcess(e))return"ignored";const t=function(e,t,s){if(e.senderId!==s)return console.error("[Security] Non-host tried to send GAME_STATE!"),{valid:!1,localHash:"",remoteHash:"",turnMatches:!1,action:"resync",reason:"SECURITY: Unauthorized sender"};if(!t)return{valid:!0,localHash:"",remoteHash:e.stateHash||"none",turnMatches:!0,action:"accept",reason:"Initial state"};const n=m(t),o=e.stateHash||"",r=function(e,t){const s=e-t;return 0===s?{valid:!0,action:"accept"}:-1===s?{valid:!0,action:"accept",reason:"Tolerated lag"}:s<-1?{valid:!1,action:"ignore",reason:`Message too old: turn ${e} vs current ${t}`}:{valid:!1,action:"resync",reason:`Missed updates: message at turn ${e}, we're at ${t}`}}(e.turnNumber,t.turnNumber);return r.valid||"ignore"!==r.action?e.turnNumber<t.turnNumber?(console.warn("[StateSync] Received older state from host - requesting resync"),{valid:!1,localHash:n,remoteHash:o,turnMatches:!1,action:"resync",reason:`Host sent older state: ${e.turnNumber} < ${t.turnNumber}`}):e.turnNumber===t.turnNumber?o&&o!==n?(console.error("[StateSync] Hash mismatch detected!"),console.error(`  Local:  ${n}`),console.error(`  Remote: ${o}`),{valid:!1,localHash:n,remoteHash:o,turnMatches:!0,action:"resync",reason:`State hash mismatch at turn ${t.turnNumber}`}):{valid:!0,localHash:n,remoteHash:o,turnMatches:!0,action:"accept"}:{valid:!0,localHash:n,remoteHash:o,turnMatches:!1,action:"accept",reason:`Catching up: ${t.turnNumber} â†’ ${e.turnNumber}`}:{valid:!1,localHash:n,remoteHash:o,turnMatches:!1,action:"resync",reason:r.reason}}(e,this.localGame,this.hostPeerId);if(!t.valid){if(console.error("[StateSync] State verification failed:",t.reason),this.resyncManager.shouldRequestResync()){const s=t.turnMatches?"HASH_MISMATCH":"TURN_MISMATCH";this.requestResync(s,e.turnNumber)}return"resync_needed"}return this.localGame=e.game,e.isResyncResponse&&this.resyncManager.markResyncCompleted(),console.log(`[StateSync] Applied state at turn ${e.turnNumber}, hash: ${t.remoteHash}`),"applied"}requestResync(e,t){this.resyncManager.markResyncRequested(),function(e,t,s,n){const o=n?.turnNumber??0,r=n?m(n):void 0;Date.now(),Math.random().toString(36).substr(2,9),Date.now()}(this.localGame,0,0,this.localGame),console.warn("[StateSync] Requesting full state resync:",e)}getLocalGame(){return this.localGame}reset(){this.deduplicator.clear(),this.resyncManager.reset()}}class R{constructor(e){this.game=e,this.resyncManager=new g,setInterval(()=>{this.resyncManager.resetCounters()},6e4)}handleResyncRequest(e,t){if(!this.resyncManager.canClientResync(t))return console.warn(`[Resync] Rate limit exceeded for client ${t}`),null;if(this.resyncManager.recordResync(t),console.log(`[Resync] Client ${t} reason: ${e.reason}`),console.log(`  Client turn: ${e.clientTurnNumber}, Host turn: ${this.game.turnNumber}`),e.clientStateHash){const t=m(this.game);console.log(`  Client hash: ${e.clientStateHash}`),console.log(`  Host hash:   ${t}`)}return{type:d.GameState,messageId:`resync_resp_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,gameId:this.game.id,senderId:"host-peer-id",turnNumber:this.game.turnNumber,timestamp:Date.now(),game:this.game,reason:"RESYNC_RESPONSE",stateHash:m(this.game),isResyncResponse:!0,resyncRequestId:e.messageId}}updateGame(e){return this.game=e,m(e)}}class C{constructor(){this.peer=null,this.hostPeerId="",this.roomCode="",this.game=null,this.syncHandler=null,this.connectedPeers=new Map,this.playerConnections=new Map,this.observers=new Set,this.config=null,this.observerModeEnabled=!1,this.autoSkipTimers=new Map,this.PEER_RECONNECT_GRACE_PERIOD=15e3,this.isProcessingAction=!1,this.eventListeners=new Map,this.deduplicator=new u}async createRoom(e,t,s=!1){if(e.length<2||e.length>5)throw new Error("Invalid player count. Must be 2-5 players.");try{this.roomCode=this.generateRoomCode();const n=e.map((e,t)=>({id:`player_${t}`,name:e}));this.game=l(n,t||this.generateSeed()),this.syncHandler=new R(this.game),this.hostPeerId=`host_${this.roomCode}_${Date.now()}`,await this.initializePeerHost(),this.config={playerNames:e,seed:t,observerMode:s},this.observerModeEnabled=s;const o={roomCode:this.roomCode,gameId:this.game.id,hostPeerId:this.hostPeerId,createdAt:Date.now(),playerCount:e.length,connectedPlayers:1,gamePhase:this.game.phase};return this.emit("room-created",o),this.saveRoomToLocalStorage(o),o}catch(n){throw console.error("[Room] Failed to create:",n),this.emit("room-error",n),n}}generateRoomCode(){const e="ABCDEFGHJKMNPQRSTUVWXYZ23456789";let t="";for(let s=0;s<6;s++){t+=e[Math.floor(31*Math.random())]}return t}generateSeed(){return`${Date.now()}_${Math.random().toString(36).substring(2,15)}`}async initializePeerHost(){return new Promise((t,s)=>{this.peer=new e(this.hostPeerId,{debug:2,host:"0.peerjs.com",port:443,path:"/",secure:!0}),this.peer.on("open",e=>{console.log("[Room] PeerJS host initialized:",e),console.log("[Room] Connected to signaling server"),this.setupPeerListeners(),t()}),this.peer.on("error",e=>{console.error("[Room] PeerJS error:",e),s(new Error(`Failed to connect to signaling server: ${e.message}`))}),this.peer.on("connection",e=>{console.log("[Room] Incoming connection from:",e.peer),this.handleIncomingConnection(e)}),this.peer.on("disconnected",()=>{console.warn("[Room] PeerJS disconnected from signaling server"),this.peer?.reconnect()})})}saveRoomToLocalStorage(e){try{if("undefined"==typeof localStorage)return void console.warn("[Room] localStorage not available");const t={...e,game:this.game,savedAt:Date.now()};localStorage.setItem(`p2p_room_${this.roomCode}`,JSON.stringify(t))}catch(t){console.warn("[Room] Failed to save to localStorage:",t)}}setupPeerListeners(){}handleIncomingConnection(e){this.emit("peer-connecting",e.peer),e.on("open",()=>{this.connectedPeers.set(e.peer,e),this.setupConnectionListeners(e)}),e.on("error",t=>{console.error("[Room] Connection error:",e.peer,t)})}setupConnectionListeners(e){e.on("data",t=>{this.handlePeerMessage(t,e.peer)}),e.on("close",()=>{this.handlePeerDisconnect(e.peer)}),e.on("error",t=>{console.error("[Room] Peer error:",e.peer,t)})}handlePeerMessage(e,t){if(this.deduplicator.shouldProcess(e))switch(e.type){case d.JoinGame:this.handleJoinRequest(e,t);break;case d.ActionRequest:this.handleActionRequest(e,t);break;default:"RESYNC_REQUEST"===e.type?this.handleResyncRequest(e,t):console.warn("[Room] Unknown message type:",e.type)}}handleJoinRequest(e,t){if(!this.game)return void this.sendError(t,"GAME_NOT_FOUND","Game not initialized");if(this.game.phase!==s.Setup)return void(this.observerModeEnabled?this.handleObserverJoin(e,t):(this.sendError(t,"GAME_ALREADY_STARTED","Game in progress"),this.emit("late-joiner-rejected",t,e.playerName)));const n=this.game.players.find(t=>t.id===e.playerId);if(!n)return void this.sendError(t,"PLAYER_NOT_FOUND","Player not in this game");if(this.playerConnections.has(e.playerId)){return this.playerConnections.get(e.playerId).connected?void this.sendError(t,"ALREADY_CONNECTED","Player already in game"):void this.handlePlayerReconnect(e,t)}const o={playerId:e.playerId,playerName:n.name,peerId:t,connected:!0,connectedAt:Date.now()};this.playerConnections.set(e.playerId,o),this.emit("peer-connected",o),this.sendGameState(t,"INITIAL_SYNC"),this.broadcastPlayerStatus(e.playerId,"connected")}handleObserverJoin(e,t){this.observers.add(t),this.sendGameState(t,"OBSERVER_JOIN");const s={type:"OBSERVER_MODE",messageId:`obs_${Date.now()}`,gameId:this.game.id,senderId:this.hostPeerId,turnNumber:this.game.turnNumber,timestamp:Date.now(),message:"Joined as observer (read-only)"};this.sendToPeer(t,s)}handleActionRequest(e,t){if(!this.game)return void this.sendActionResult(t,e.messageId,!1,"Game not found");if(this.isProcessingAction)return void this.sendActionResult(t,e.messageId,!1,"Host is processing another action. Please wait.");this.isProcessingAction=!0;const s=this.processAction(e.action);this.sendActionResult(t,e.messageId,s.valid,s.error),this.isProcessingAction=!1,this.emit("action-processed",e.action,s.valid)}processAction(e){if(!this.game)return this.isProcessingAction=!1,{valid:!1,error:"Game not initialized"};const t=o(this.game,e);if(!t.valid)return this.isProcessingAction=!1,{valid:!1,error:t.error,code:t.code};let s=r(this.game,e);const n=i(s);return s=n.game,n.gameFinished&&(s=a(s)),this.game=s,this.syncHandler&&this.syncHandler.updateGame(s),this.broadcastGameState(s,e),this.emit("game-state-updated",s),{valid:!0}}broadcastGameState(e,t){const s=m(e),n={type:d.GameState,messageId:`state_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,gameId:e.id,senderId:this.hostPeerId,turnNumber:e.turnNumber,timestamp:Date.now(),game:e,reason:"ACTION_APPLIED",lastAction:t,stateHash:s};console.log("[Room] Broadcasting state to",this.connectedPeers.size,"peers"),this.connectedPeers.forEach((e,t)=>{try{e.send(n)}catch(s){console.error("[Room] Failed to send to",t,s)}})}sendGameState(e,t){if(!this.game)return;const s=m(this.game),n={type:d.GameState,messageId:`state_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,gameId:this.game.id,senderId:this.hostPeerId,turnNumber:this.game.turnNumber,timestamp:Date.now(),game:this.game,reason:t,stateHash:s};this.sendToPeer(e,n)}handlePeerDisconnect(e){let t;if(this.connectedPeers.delete(e),this.playerConnections.forEach(s=>{s.peerId===e&&s.connected&&(s.connected=!1,s.disconnectTime=Date.now(),t=s)}),t){if(this.emit("peer-disconnected",e,t.playerName),this.game){this.game.players[this.game.currentPlayerIndex].id===t.playerId&&this.handleCurrentPlayerDisconnect(t)}this.broadcastPlayerStatus(t.playerId,"disconnected")}else this.observers.has(e)&&(this.observers.delete(e),console.log("[Room] Observer disconnected:",e))}handleCurrentPlayerDisconnect(e){console.log("[Room] Current player disconnected, starting grace period");const t=setTimeout(()=>{e.connected||(console.log("[Room] Grace period expired, auto-skipping turn"),this.autoSkipTurn(e.playerId)),this.autoSkipTimers.delete(e.playerId)},this.PEER_RECONNECT_GRACE_PERIOD);this.autoSkipTimers.set(e.playerId,t)}autoSkipTurn(e){if(!this.game)return;if(this.game.players[this.game.currentPlayerIndex].id!==e)return;const t=this.playerConnections.get(e);if(!t)return;console.log("[Room] Auto-skipping turn for:",t.playerName);const s={type:"REST",playerId:e,timestamp:Date.now()};this.processAction(s).valid&&this.emit("turn-auto-skipped",e,t.playerName)}handlePlayerReconnect(e,t){const s=this.playerConnections.get(e.playerId);if(!s)return;console.log("[Room] Player reconnecting:",s.playerName);const n=this.autoSkipTimers.get(e.playerId);n&&(clearTimeout(n),this.autoSkipTimers.delete(e.playerId),console.log("[Room] Cancelled auto-skip timer")),s.peerId=t,s.connected=!0,s.disconnectTime=void 0,this.sendGameState(t,"RECONNECT"),this.emit("peer-reconnected",t,s.playerName),this.broadcastPlayerStatus(e.playerId,"connected")}handleResyncRequest(e,t){if(!this.syncHandler||!this.game)return;console.log("[Room] Resync request from:",t,"reason:",e.reason);const s=this.syncHandler.handleResyncRequest(e,t);s?this.sendToPeer(t,s):console.warn("[Room] Resync rejected (rate limited)")}sendToPeer(e,t){const s=this.connectedPeers.get(e);if(s)try{s.send(t)}catch(n){console.error("[Room] Failed to send to",e,n)}}sendActionResult(e,t,s,n){const o=h.createActionResult(this.game.id,this.hostPeerId,this.game.turnNumber,t,s,s?this.game.turnNumber:void 0,n);this.sendToPeer(e,o)}sendError(e,t,s){const n=h.createError(this.game?.id||"",this.hostPeerId,this.game?.turnNumber||0,"ERROR",t,s,!0);this.sendToPeer(e,n),setTimeout(()=>{const t=this.connectedPeers.get(e);t&&t.close()},1e3)}broadcastPlayerStatus(e,t){const s={type:"PLAYER_STATUS",messageId:`status_${Date.now()}`,gameId:this.game?.id,senderId:this.hostPeerId,turnNumber:this.game?.turnNumber||0,timestamp:Date.now(),playerId:e,status:t};this.connectedPeers.forEach((e,t)=>{this.observers.has(t)||this.sendToPeer(t,s)})}getRoomCode(){return this.roomCode}getHostPeerId(){return this.hostPeerId}getGame(){return this.game}getRoomInfo(){return this.game?{roomCode:this.roomCode,gameId:this.game.id,hostPeerId:this.hostPeerId,createdAt:this.config?Date.now():0,playerCount:this.game.players.length,connectedPlayers:this.getConnectedPlayerCount(),gamePhase:this.game.phase}:null}getConnectedPlayers(){return Array.from(this.playerConnections.values())}getConnectedPlayerCount(){let e=1;return this.playerConnections.forEach(t=>{t.connected&&e++}),e}close(){console.log("[Room] Closing room"),this.autoSkipTimers.forEach(e=>clearTimeout(e)),this.autoSkipTimers.clear(),this.connectedPeers.forEach((e,t)=>{try{const t={type:"GAME_ENDED",messageId:`end_${Date.now()}`,gameId:this.game?.id,senderId:this.hostPeerId,turnNumber:this.game?.turnNumber||0,timestamp:Date.now(),reason:"Host closed room"};e.send(t),e.close()}catch(s){console.error("[Room] Error closing connection:",s)}}),this.peer&&(this.peer.destroy(),this.peer=null),this.connectedPeers.clear(),this.playerConnections.clear(),this.observers.clear(),console.log("[Room] Closed")}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e).add(t)}off(e,t){const s=this.eventListeners.get(e);s&&s.delete(t)}emit(e,...t){const s=this.eventListeners.get(e);s&&s.forEach(e=>{try{e(...t)}catch(s){console.error("[Room] Event listener error:",s)}})}}class I{constructor(){this.peer=null,this.hostConnection=null,this.clientPeerId="",this.roomCode="",this.hostPeerId="",this.playerId="",this.playerName="",this.game=null,this.syncHandler=null,this.connected=!1,this.connecting=!1,this.reconnectAttempts=0,this.MAX_RECONNECT_ATTEMPTS=5,this.reconnectTimer=null,this.RECONNECT_DELAY=3e3,this.hostAliveTimer=null,this.lastHostMessage=0,this.HOST_TIMEOUT=3e4,this.pendingActions=new Map,this.ACTION_TIMEOUT=1e4,this.eventListeners=new Map,this.deduplicator=new u}async joinRoom(e,t,s,n=6e4){if(this.connected||this.connecting)throw new Error("Already connected or connecting to a room");this.connecting=!0,this.roomCode=e.toUpperCase(),this.playerId=t,this.playerName=s;try{this.clientPeerId=`client_${t}_${Date.now()}`,await this.initializePeerClient(),this.hostPeerId=await this.discoverHostPeerId(e,n),await this.connectToHost(n),await this.sendJoinRequest(),await this.waitForInitialState(n),this.startHostMonitoring(),this.connected=!0,this.connecting=!1,this.reconnectAttempts=0;const s={roomCode:this.roomCode,gameId:this.game.id,hostPeerId:this.hostPeerId,playerId:this.playerId,playerName:this.playerName,connected:!0,connectedAt:Date.now()};return console.log("[Client] Successfully joined room:",s),this.emit("connected",s),s}catch(o){throw this.connecting=!1,console.error("[Client] Failed to join room:",o),this.emit("error",o),this.cleanup(),o}}async initializePeerClient(){return new Promise((t,s)=>{this.peer=new e(this.clientPeerId,{debug:2,host:"0.peerjs.com",port:443,path:"/",secure:!0}),this.peer.on("open",e=>{console.log("[Client] PeerJS initialized:",e),console.log("[Client] Connected to signaling server"),t()}),this.peer.on("error",e=>{console.error("[Client] PeerJS error:",e),s(new Error(`Failed to connect to signaling server: ${e.message}`))}),this.peer.on("disconnected",()=>{console.warn("[Client] PeerJS disconnected from signaling server"),this.peer?.reconnect()})})}async discoverHostPeerId(e,t){const s=this.getCachedHostPeerId(e);if(s)return console.log("[Client] Using cached host peer ID:",s),s;throw new Error("Host peer ID not found. Please provide the full peer ID along with room code. Host should share both: Room Code + Host Peer ID")}getCachedHostPeerId(e){try{if("undefined"==typeof localStorage)return null;const t=localStorage.getItem(`host_peer_${e}`);if(t){const e=JSON.parse(t);if(Date.now()-e.timestamp<36e5)return e.peerId}}catch(t){console.warn("[Client] Failed to read cache:",t)}return null}async connectToHost(e){return new Promise((t,s)=>{console.log("[Client] Connecting to host:",this.hostPeerId);const n=setTimeout(()=>{this.hostConnection?.close(),s(new Error("Connection timeout. Make sure you and the host are on the same network (WiFi). Check that the Host Peer ID is correct."))},e);this.hostConnection=this.peer.connect(this.hostPeerId,{reliable:!0,serialization:"json"}),this.hostConnection.on("open",()=>{clearTimeout(n),console.log("[Client] Connected to host"),this.setupConnectionListeners(),t()}),this.hostConnection.on("error",e=>{clearTimeout(n),console.error("[Client] Connection error:",e),s(new Error(`Connection failed: ${e.message}. Ensure you're on the same network as the host.`))})})}setupConnectionListeners(){this.hostConnection&&(this.hostConnection.on("data",e=>{this.lastHostMessage=Date.now(),this.handleHostMessage(e)}),this.hostConnection.on("close",()=>{console.log("[Client] Host connection closed"),this.handleHostDisconnect()}),this.hostConnection.on("error",e=>{console.error("[Client] Host connection error:",e)}))}async sendJoinRequest(){const e=h.createJoinGame("",this.clientPeerId,this.playerId,this.playerName,"1.0.0",void 0);this.sendToHost(e),console.log("[Client] Sent JOIN_GAME request")}async waitForInitialState(e){return new Promise((t,s)=>{const n=setTimeout(()=>{s(new Error("Timeout waiting for initial game state"))},e),o=e=>{clearTimeout(n),this.off("game-state-received",o),t()};this.on("game-state-received",o)})}handleHostMessage(e){if(this.deduplicator.shouldProcess(e))switch(console.log("[Client] Received message:",e.type),e.type){case d.GameState:this.handleGameState(e);break;case d.ActionResult:this.handleActionResult(e);break;case d.Error:this.handleError(e);break;default:"RESYNC_RESPONSE"===e.type?this.handleResyncResponse(e):"PLAYER_STATUS"===e.type?this.handlePlayerStatus(e):"GAME_ENDED"===e.type?this.handleGameEnded(e):console.warn("[Client] Unknown message type:",e.type)}else console.log("[Client] Ignoring duplicate message:",e.messageId)}handleGameState(e){if(console.log("[Client] Received game state, turn:",e.turnNumber),!this.syncHandler)return this.syncHandler=new y(this.hostPeerId),this.game=e.game,console.log("[Client] Initial state received"),void this.emit("game-state-received",e.game);const t=this.syncHandler.handleGameState(e);"applied"===t?(this.game=e.game,console.log("[Client] State updated successfully"),this.emit("game-state-received",e.game)):"resync_needed"===t?(console.warn("[Client] State mismatch detected, requesting resync"),this.requestResync("STATE_MISMATCH")):console.log("[Client] State message ignored (stale or duplicate)")}handleActionResult(e){console.log("[Client] Action result:",e.success?"accepted":"rejected");const t=this.pendingActions.get(e.requestMessageId);t?(this.pendingActions.delete(e.requestMessageId),e.success?(t.resolve(!0),this.emit("action-accepted",t.action)):(t.resolve(!1),this.emit("action-rejected",t.action,e.errorMessage||"Unknown error"))):console.warn("[Client] Received result for unknown action")}handleError(e){console.error("[Client] Error from host:",e.errorCode,e.message),e.willDisconnect&&(this.emit("error",new Error(`Fatal error: ${e.message}`)),this.disconnect())}handleResyncResponse(e){console.log("[Client] Resync response received"),e.game&&(this.game=e.game,this.emit("resync-complete",e.game),this.emit("game-state-received",e.game))}handlePlayerStatus(e){console.log("[Client] Player status update:",e.playerId,e.status),this.emit("player-status-changed",e.playerId,e.status)}handleGameEnded(e){console.log("[Client] Game ended:",e.reason),this.disconnect()}async sendAction(e){if(!this.connected||!this.game)throw new Error("Not connected to room");if(e.playerId!==this.playerId)throw new Error("Cannot send action for another player");return new Promise((t,s)=>{const n=h.createActionRequest(this.game.id,this.clientPeerId,this.game.turnNumber,e);this.pendingActions.set(n.messageId,{action:e,resolve:t,reject:s,timestamp:Date.now()}),setTimeout(()=>{this.pendingActions.has(n.messageId)&&(this.pendingActions.delete(n.messageId),s(new Error("Action request timeout")))},this.ACTION_TIMEOUT),this.sendToHost(n),console.log("[Client] Sent action request:",e.type)})}requestResync(e){if(!this.game)return;const t={type:"RESYNC_REQUEST",messageId:`resync_${Date.now()}`,gameId:this.game.id,senderId:this.clientPeerId,turnNumber:this.game.turnNumber,timestamp:Date.now(),reason:e,clientTurnNumber:this.game.turnNumber,clientStateHash:m(this.game)};this.sendToHost(t),console.log("[Client] Requested state resync:",e)}startHostMonitoring(){this.lastHostMessage=Date.now(),this.hostAliveTimer=setInterval(()=>{const e=Date.now()-this.lastHostMessage;e>this.HOST_TIMEOUT&&(console.error("[Client] Host timeout - no messages for",e,"ms"),this.handleHostDisconnect())},5e3)}stopHostMonitoring(){this.hostAliveTimer&&(clearInterval(this.hostAliveTimer),this.hostAliveTimer=null)}handleHostDisconnect(){this.connected&&(console.warn("[Client] Host disconnected"),this.connected=!1,this.stopHostMonitoring(),this.emit("host-disconnected"),this.emit("disconnected","Host disconnected"),this.attemptReconnect())}attemptReconnect(){if(this.reconnectAttempts>=this.MAX_RECONNECT_ATTEMPTS)return console.error("[Client] Max reconnect attempts reached"),this.emit("error",new Error("Failed to reconnect to host")),void this.cleanup();this.reconnectAttempts++,console.log(`[Client] Reconnect attempt ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS}`),this.emit("reconnecting"),this.reconnectTimer=setTimeout(async()=>{try{await this.connectToHost(1e4),await this.sendJoinRequest(),this.connected=!0,this.reconnectAttempts=0,this.startHostMonitoring(),console.log("[Client] Reconnected successfully"),this.emit("reconnected")}catch(e){console.error("[Client] Reconnect failed:",e),this.attemptReconnect()}},this.RECONNECT_DELAY)}disconnect(){console.log("[Client] Disconnecting"),this.connected=!1,this.connecting=!1,this.stopHostMonitoring(),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.cleanup(),this.emit("disconnected","User disconnected")}cleanup(){if(this.hostConnection){try{this.hostConnection.close()}catch(e){console.error("[Client] Error closing host connection:",e)}this.hostConnection=null}if(this.peer){try{this.peer.destroy()}catch(e){console.error("[Client] Error destroying peer:",e)}this.peer=null}this.pendingActions.forEach(e=>{e.reject(new Error("Disconnected"))}),this.pendingActions.clear()}sendToHost(e){if(this.hostConnection)try{this.hostConnection.send(e)}catch(t){console.error("[Client] Failed to send to host:",t)}}getGame(){return this.game}isConnected(){return this.connected}getClientInfo(){return this.game?{roomCode:this.roomCode,gameId:this.game.id,hostPeerId:this.hostPeerId,playerId:this.playerId,playerName:this.playerName,connected:this.connected,connectedAt:this.connected?Date.now():void 0}:null}async joinRoomWithPeerId(e,t,s,n,o=6e4){return this.cacheHostPeerId(e,t),this.hostPeerId=t,this.joinRoom(e,s,n,o)}cacheHostPeerId(e,t){try{if("undefined"==typeof localStorage)return;const s={peerId:t,timestamp:Date.now()};localStorage.setItem(`host_peer_${e}`,JSON.stringify(s))}catch(s){console.warn("[Client] Failed to cache host peer ID:",s)}}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e).add(t)}off(e,t){const s=this.eventListeners.get(e);s&&s.delete(t)}emit(e,...t){const s=this.eventListeners.get(e);s&&s.forEach(e=>{try{e(...t)}catch(s){console.error("[Client] Event listener error:",s)}})}}export{C as P,I as a};
//# sourceMappingURL=p2p-BYyn1xEK.js.map
